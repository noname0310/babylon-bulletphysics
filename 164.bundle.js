"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[164],{67168:(e,t,r)=>{r.d(t,{vC:()=>o});class n{_wasmInstance;_ptr;_bodyReference;_referenceCount;constructor(e,t,r){this._wasmInstance=e,this._ptr=t,this._bodyReference=r,Array.isArray(r)?(r[0].addReference(),r[1].addReference()):r.addReference(),this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose constraint while it still has references");0!==this._ptr&&(this._wasmInstance.deref()?.destroyConstraint(this._ptr),this._ptr=0,Array.isArray(this._bodyReference)?(this._bodyReference[0].removeReference(),this._bodyReference[1].removeReference()):this._bodyReference.removeReference(),this._bodyReference=null)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}}function i(e){e.dispose()}const s=new WeakMap;class a{runtime;_inner;_worldReference;constructor(e,t,r){if(Array.isArray(r)){if(r[0].runtime!==e||r[1].runtime!==e)throw new Error("Cannot create constraint between bodies from different runtimes")}else if(r.runtime!==e)throw new Error("Cannot create constraint between body and bundle from different runtimes");this.runtime=e,this._inner=new n(new WeakRef(e.wasmInstance),t,r),this._worldReference=null;let a=s.get(e.wasmInstance);void 0===a&&(a=new FinalizationRegistry(i),s.set(e.wasmInstance,a)),a.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add constraint to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}}class o extends a{constructor(e,t,r,n,i,s){const a=e.wasmInstance,o=a.allocateBuffer(64),h=a.createTypedArray(Float32Array,o,16);n.copyToArray(h.array);const c=a.allocateBuffer(64),l=a.createTypedArray(Float32Array,c,16);i.copyToArray(l.array);const u=Array.isArray(r),_=u?a.createGeneric6DofSpringConstraintFromBundle(t.ptr,r[0],r[1],o,c,s):a.createGeneric6DofSpringConstraint(t.ptr,r.ptr,o,c,s);a.deallocateBuffer(o,64),a.deallocateBuffer(c,64),super(e,_,u?t:[t,r])}setLinearLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setLinearUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearUpperLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularUpperLimit(this._inner.ptr,e.x,e.y,e.z)}enableSpring(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintEnableSpring(this._inner.ptr,e,t)}setStiffness(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetStiffness(this._inner.ptr,e,t)}setDamping(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetDamping(this._inner.ptr,e,t)}}},1592:(e,t,r)=>{r.d(t,{U:()=>a});class n{_wasmInstance;_ptr;_shapeReference;_referenceCount;_shadowCount;constructor(e,t,r){this._wasmInstance=e,this._ptr=t,this._shapeReference=r,r.addReference(),this._referenceCount=0,this._shadowCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose rigid body while it still has references");if(this._shadowCount>0)throw new Error("Cannot dispose rigid body while it still has shadows");0!==this._ptr&&(this._wasmInstance.deref()?.destroyRigidBody(this._ptr),this._ptr=0,this._shapeReference.removeReference(),this._shapeReference=null)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}addShadow(){this._shadowCount+=1}removeShadow(){this._shadowCount-=1}get hasShadows(){return 0<this._shadowCount}}function i(e){e.dispose()}const s=new WeakMap;class a{runtime;_motionStatePtr;_bufferedMotionStatePtr;_inner;_worldReference;impl;isDynamic;constructor(e,t,r){const a=void 0!==r?t.getPtr(r):t.ptr;if(0===a)throw new Error("Cannot create rigid body with null pointer");let o;if(o=void 0!==r?t.getShape(r):t.shape,null===o)throw new Error("Cannot create rigid body with null shape");if(o.runtime!==e)throw new Error("Cannot create rigid body with shapes from different runtimes");this.runtime=e;const h=e.wasmInstance,c=h.createRigidBody(a),l=h.rigidBodyGetMotionStatePtr(c);this._motionStatePtr=h.createTypedArray(Float32Array,l,20);const u=h.rigidBodyGetBufferedMotionStatePtr(c);this._bufferedMotionStatePtr=h.createTypedArray(Float32Array,u,20),this._inner=new n(new WeakRef(e.wasmInstance),c,o),this._worldReference=null;let _=s.get(h);void 0===_&&(_=new FinalizationRegistry(i),s.set(h,_)),_.register(this,this._inner,this),this.impl=e.createRigidBodyImpl(),this.isDynamic=void 0!==r?0===t.getMotionType(r):0===t.motionType}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}addShadowReference(){this._inner.addShadow()}removeShadowReference(){this._inner.removeShadow()}get hasShadows(){return this._inner.hasShadows}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add rigid body to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==this._worldReference?this._inner.addReference():this._inner.removeReference())}getWorldReference(){return this._worldReference}updateBufferedMotionState(e){if(this._nullCheck(),e){const e=this.runtime.wasmInstance.rigidBodyGetMotionStatePtr(this._inner.ptr);this._bufferedMotionStatePtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20)}else{const e=this.runtime.wasmInstance.rigidBodyGetBufferedMotionStatePtr(this._inner.ptr);this._bufferedMotionStatePtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20)}}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed rigid body")}makeKinematic(){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyMakeKinematic(this._inner.ptr)}restoreDynamic(){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyRestoreDynamic(this._inner.ptr)}getTransformMatrixToRef(e){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const t=this._bufferedMotionStatePtr.array;return e.set(t[4],t[8],t[12],0,t[5],t[9],t[13],0,t[6],t[10],t[14],0,t[16],t[17],t[18],1)}getTransformMatrixToArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatePtr.array;e[t+0]=r[4],e[t+1]=r[8],e[t+2]=r[12],e[t+3]=0,e[t+4]=r[5],e[t+5]=r[9],e[t+6]=r[13],e[t+7]=0,e[t+8]=r[6],e[t+9]=r[10],e[t+10]=r[14],e[t+11]=0,e[t+12]=r[16],e[t+13]=r[17],e[t+14]=r[18],e[t+15]=1}setTransformMatrix(e){this.setTransformMatrixFromArray(e.m,0)}setTransformMatrixFromArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatrixFromArray(this._motionStatePtr,e,t)}}},67648:(e,t,r)=>{r.d(t,{Y:()=>a});class n{_wasmInstance;_ptr;_shapeReferences;_referenceCount;_shadowCount;constructor(e,t,r){this._wasmInstance=e,this._ptr=t,this._shapeReferences=r;for(const e of r)e.addReference();this._referenceCount=0,this._shadowCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose rigid body bundle while it still has references");if(0!==this._ptr){this._wasmInstance.deref()?.destroyRigidBodyBundle(this._ptr),this._ptr=0;for(const e of this._shapeReferences)e.removeReference();this._shapeReferences.clear()}}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}addShadow(){this._shadowCount+=1}removeShadow(){this._shadowCount-=1}get hasShadows(){return 0<this._shadowCount}}function i(e){e.dispose()}const s=new WeakMap;class a{runtime;_motionStatesPtr;_bufferedMotionStatesPtr;_inner;_count;_worldReference;impl;isContainsDynamic;constructor(e,t){if(0===t.ptr)throw new Error("Cannot create rigid body bundle with null pointer");const r=t.count,a=new Set;for(let n=0;n<r;++n){const r=t.getShape(n);if(null===r)throw new Error("Cannot create rigid body bundle with null shape");if(r.runtime!==e)throw new Error("Cannot create rigid body bundle with shapes from different runtimes");a.add(r)}this.runtime=e;const o=e.wasmInstance,h=o.createRigidBodyBundle(t.ptr,r),c=o.rigidBodyBundleGetMotionStatesPtr(h);this._motionStatesPtr=o.createTypedArray(Float32Array,c,20*r);const l=o.rigidBodyBundleGetBufferedMotionStatesPtr(h);this._bufferedMotionStatesPtr=o.createTypedArray(Float32Array,l,20*r),this._inner=new n(new WeakRef(e.wasmInstance),h,a),this._count=r,this._worldReference=null;let u=s.get(o);void 0===u&&(u=new FinalizationRegistry(i),s.set(o,u)),u.register(this,this._inner,this),this.impl=e.createRigidBodyBundleImpl(this);let _=!1;for(let e=0;e<r;++e)if(0===t.getMotionType(e)){_=!0;break}this.isContainsDynamic=_}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}get count(){return this._count}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}addShadowReference(){this._inner.addShadow()}removeShadowReference(){this._inner.removeShadow()}get hasShadows(){return this._inner.hasShadows}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add rigid body bundle to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}getWorldReference(){return this._worldReference}updateBufferedMotionStates(e){if(this._nullCheck(),e){const e=this.runtime.wasmInstance.rigidBodyBundleGetMotionStatesPtr(this._inner.ptr);this._bufferedMotionStatesPtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20*this._count)}else{const e=this.runtime.wasmInstance.rigidBodyBundleGetBufferedMotionStatesPtr(this._inner.ptr);this._bufferedMotionStatesPtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20*this._count)}}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed rigid body bundle")}makeKinematic(e){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleMakeKinematic(this._inner.ptr,e)}restoreDynamic(e){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleRestoreDynamic(this._inner.ptr,e)}getTransformMatrixToRef(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatesPtr.array,n=20*e;return t.set(r[n+4+0],r[n+8+0],r[n+12+0],0,r[n+4+1],r[n+8+1],r[n+12+1],0,r[n+4+2],r[n+8+2],r[n+12+2],0,r[n+16+0],r[n+16+1],r[n+16+2],1)}getTransformMatrixToArray(e,t,r=0){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const n=this._bufferedMotionStatesPtr.array,i=20*e;t[r+0]=n[i+4+0],t[r+1]=n[i+8+0],t[r+2]=n[i+12+0],t[r+3]=0,t[r+4]=n[i+4+1],t[r+5]=n[i+8+1],t[r+6]=n[i+12+1],t[r+7]=0,t[r+8]=n[i+4+2],t[r+9]=n[i+8+2],t[r+10]=n[i+12+2],t[r+11]=0,t[r+12]=n[i+16+0],t[r+13]=n[i+16+1],t[r+14]=n[i+16+2],t[r+15]=1}getTransformMatricesToArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatesPtr.array,n=this._count;let i=0,s=t;for(let t=0;t<n;++t)e[s+0]=r[i+4+0],e[s+1]=r[i+8+0],e[s+2]=r[i+12+0],e[s+3]=0,e[s+4]=r[i+4+1],e[s+5]=r[i+8+1],e[s+6]=r[i+12+1],e[s+7]=0,e[s+8]=r[i+4+2],e[s+9]=r[i+8+2],e[s+10]=r[i+12+2],e[s+11]=0,e[s+12]=r[i+16+0],e[s+13]=r[i+16+1],e[s+14]=r[i+16+2],e[s+15]=1,i+=20,s+=16}setTransformMatrix(e,t){this.setTransformMatrixFromArray(e,t.m,0)}setTransformMatrixFromArray(e,t,r=0){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatrixFromArray(this._motionStatesPtr,e,t,r)}setTransformMatricesFromArray(e,t=0){if(this._nullCheck(),e.length<16*this._count)throw new RangeError("Array is too short");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatricesFromArray(this._motionStatesPtr,e,t)}}},3477:(e,t,r)=>{r.d(t,{x:()=>a});class n{_wasmInstance;_ptr;_count;_shapeReferences;constructor(e,t,r){this._wasmInstance=e,this._ptr=t,this._count=r,this._shapeReferences=new Array(r).fill(null)}dispose(){if(0!==this._ptr){this._wasmInstance.deref()?.deallocateBuffer(this._ptr,128*this._count),this._ptr=0;for(let e=0;e<this._shapeReferences.length;++e){const t=this._shapeReferences[e];t?.removeReference()}this._shapeReferences.fill(null)}}get ptr(){return this._ptr}get count(){return this._count}getShape(e){return this._shapeReferences[e]??null}setShape(e,t){if(e<0||this._count<=e)throw new RangeError("Index out of range");const r=this._shapeReferences[e];r&&r.removeReference(),this._shapeReferences[e]=t,t&&t.addReference()}}function i(e){e.dispose()}const s=new WeakMap;class a{_wasmInstance;_uint32Ptr;_float32Ptr;_uint8Ptr;_uint16Ptr;_inner;constructor(e,t){this._wasmInstance=e;const r=e.allocateBuffer(128*t);this._uint32Ptr=e.createTypedArray(Uint32Array,r,32*t),this._float32Ptr=e.createTypedArray(Float32Array,r,32*t),this._uint8Ptr=e.createTypedArray(Uint8Array,r,128*t),this._uint16Ptr=e.createTypedArray(Uint16Array,r,64*t),this._inner=new n(new WeakRef(e),r,t);const a=this._uint32Ptr.array,o=this._float32Ptr.array,h=this._uint8Ptr.array,c=this._uint16Ptr.array;for(let e=0;e<t;++e){const t=128*e;a[(t+0)/4]=0,o[(t+16)/4+0]=1,o[(t+16)/4+1]=0,o[(t+16)/4+2]=0,o[(t+16)/4+3]=0,o[(t+16)/4+4]=0,o[(t+16)/4+5]=1,o[(t+16)/4+6]=0,o[(t+16)/4+7]=0,o[(t+16)/4+8]=0,o[(t+16)/4+9]=0,o[(t+16)/4+10]=1,o[(t+16)/4+11]=0,o[(t+16)/4+12]=0,o[(t+16)/4+13]=0,o[(t+16)/4+14]=0,o[(t+16)/4+15]=1,h[(t+80)/1]=0,o[(t+84)/4]=1,o[(t+88)/4]=0,o[(t+92)/4]=0,o[(t+96)/4]=.5,o[(t+100)/4]=0,o[(t+104)/4]=0,o[(t+108)/4]=1,c[(t+112)/2]=1,c[(t+114)/2]=65535,h[(t+116)/1]=0,h[(t+117)/1]=0,h[(t+118)/1]=0}let l=s.get(e);void 0===l&&(l=new FinalizationRegistry(i),s.set(e,l)),l.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this._wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}get count(){return this._inner.count}getPtr(e){return this._nullCheck(),this._inner.ptr+128*e}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed RigidBodyConstructionInfo")}getShape(e){return this._nullCheck(),this._inner.getShape(e)}setShape(e,t){this._nullCheck(),this._inner.setShape(e,t);const r=128*e;this._uint32Ptr.array[(r+0)/4]=t?t.ptr:0}getInitialTransformToRef(e,t){this._nullCheck();const r=128*e,n=this._float32Ptr.array;return t.set(n[(r+16)/4+0],n[(r+16)/4+1],n[(r+16)/4+2],n[(r+16)/4+3],n[(r+16)/4+4],n[(r+16)/4+5],n[(r+16)/4+6],n[(r+16)/4+7],n[(r+16)/4+8],n[(r+16)/4+9],n[(r+16)/4+10],n[(r+16)/4+11],n[(r+16)/4+12],n[(r+16)/4+13],n[(r+16)/4+14],n[(r+16)/4+15]),t}setInitialTransform(e,t){this._nullCheck();const r=128*e,n=this._float32Ptr.array;t.copyToArray(n,(r+16)/4)}getMotionType(e){this._nullCheck();const t=128*e;return this._uint8Ptr.array[(t+80)/1]}setMotionType(e,t){this._nullCheck();const r=128*e;this._uint8Ptr.array[(r+80)/1]=t}getMass(e){this._nullCheck();const t=128*e;return this._float32Ptr.array[(t+84)/4]}setMass(e,t){this._nullCheck();const r=128*e;this._float32Ptr.array[(r+84)/4]=t}getLinearDamping(e){this._nullCheck();const t=128*e;return this._float32Ptr.array[(t+88)/4]}setLinearDamping(e,t){this._nullCheck();const r=128*e;this._float32Ptr.array[(r+88)/4]=t}getAngularDamping(e){this._nullCheck();const t=128*e;return this._float32Ptr.array[(t+92)/4]}setAngularDamping(e,t){this._nullCheck();const r=128*e;this._float32Ptr.array[(r+92)/4]=t}getFriction(e){this._nullCheck();const t=128*e;return this._float32Ptr.array[(t+96)/4]}setFriction(e,t){this._nullCheck();const r=128*e;this._float32Ptr.array[(r+96)/4]=t}getRestitution(e){this._nullCheck();const t=128*e;return this._float32Ptr.array[(t+100)/4]}setRestitution(e,t){this._nullCheck();const r=128*e;this._float32Ptr.array[(r+100)/4]=t}getLinearSleepingThreshold(e){this._nullCheck();const t=128*e;return this._float32Ptr.array[(t+104)/4]}setLinearSleepingThreshold(e,t){this._nullCheck();const r=128*e;this._float32Ptr.array[(r+104)/4]=t}getAngularSleepingThreshold(e){this._nullCheck();const t=128*e;return this._float32Ptr.array[(t+108)/4]}setAngularSleepingThreshold(e,t){this._nullCheck();const r=128*e;this._float32Ptr.array[(r+108)/4]=t}getCollisionGroup(e){this._nullCheck();const t=128*e;return this._uint16Ptr.array[(t+112)/2]}setCollisionGroup(e,t){this._nullCheck();const r=128*e;this._uint16Ptr.array[(r+112)/2]=t}getCollisionMask(e){this._nullCheck();const t=128*e;return this._uint16Ptr.array[(t+114)/2]}setCollisionMask(e,t){this._nullCheck();const r=128*e;this._uint16Ptr.array[(r+114)/2]=t}getAdditionalDamping(e){this._nullCheck();const t=128*e;return!!this._uint8Ptr.array[(t+116)/1]}setAdditionalDamping(e,t){this._nullCheck();const r=128*e;this._uint8Ptr.array[(r+116)/1]=+t}getNoContactResponse(e){this._nullCheck();const t=128*e;return!!this._uint8Ptr.array[(t+117)/1]}setNoContactResponse(e,t){this._nullCheck();const r=128*e;this._uint8Ptr.array[(r+117)/1]=+t}getDisableDeactivation(e){this._nullCheck();const t=128*e;return!!this._uint8Ptr.array[(t+118)/1]}setDisableDeactivation(e,t){this._nullCheck();const r=128*e;this._uint8Ptr.array[(r+118)/1]=+t}}}}]);