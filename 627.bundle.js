"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[627],{627:(e,t,n)=>{n.r(t),n.d(t,{SceneBuilder:()=>b}),n(203),n(1440),n(1503),n(8227);var r=n(7456),i=n(5581),s=n(1513),o=n(9711),a=n(6041),h=n(9923),c=n(9899),l=n(8144),u=n(8121),d=n(554),m=n(6738),f=n(7168),w=n(3948),p=n(9009),_=n(7744),y=n(6405),g=n(1592),R=n(7648),S=n(5901),T=n(3477),P=n(9800),C=n(2399);class b{async build(e,t){const n=new d.Z(t);n.clearColor=new a.ov(.95,.95,.95,1);const b=new r.Lq("arcRotateCamera",0,0,500,new h.Pq(0,0,0),n);b.minZ=1,b.maxZ=3e3,b.setPosition(new h.Pq(60,40,-50).scaleInPlace(10)),b.attachControl(void 0,!1),b.inertia=.8,b.speed=10;const I=new s.g("hemisphericLight",new h.Pq(0,1,0),n);I.intensity=.5,I.specular=new a.v9(0,0,0),I.groundColor=new a.v9(1,1,1);const x=new i.Z("directionalLight",new h.Pq(.5,-1,1),n);x.intensity=.5;x.shadowMaxZ=250,x.shadowMinZ=-250,x.autoCalcShadowZBounds=!1,x.autoUpdateExtends=!1,x.shadowOrthoScale=0,x.orthoTop=250,x.orthoBottom=-250,x.orthoLeft=-250,x.orthoRight=250;const M=new o.o(2048,x,!0);M.transparencyShadow=!0,M.usePercentageCloserFiltering=!0,M.forceBackFacesOnly=!1,M.bias=.004,M.filteringQuality=o.o.QUALITY_MEDIUM;const k=parseInt(prompt("Thread count","2"));console.log("Thread count:",k);const A=await(0,m.e)(new _.t,k),B=new w.h(A,{allowDynamicShadow:!1,preserveBackBuffer:!1}),v=prompt("Evaluation type (i, b) immediate, buffered","i");B.evaluationType="i"===v?p.q.Immediate:p.q.Buffered;const E=new h.uq;{const e=(0,l.x)("ground",{size:500},n);e.rotationQuaternion=h.PT.RotationAxis(new h.Pq(1,0,0),Math.PI/2),M.addShadowCaster(e),e.receiveShadows=!0;const t=new y.Ty(B,new h.Pq(0,0,-1),0),r=new S.t(A);r.shape=t,h.uq.FromQuaternionToRef(e.rotationQuaternion,E),r.setInitialTransform(E),r.motionType=1;const i=new g.U(B,r);B.addRigidBodyToGlobal(i)}const q=512,F=[],L=[];if("u"===prompt("Shape type (u, r) uniform box, random","u")){const e=new h.Pq(1,1,1),t=new y.SA(B,e),n={type:"box",size:e};for(let e=0;e<q;++e)F.push(t),L.push(n)}else{const e=new C.q(0);for(let t=0;t<q;++t){const t=2*e.next()|0;if(0===t){const t=2*e.next()+.5,n=2*e.next()+.5,r=2*e.next()+.5,i=new h.Pq(t,n,r);F.push(new y.SA(B,i)),L.push({type:"box",size:i})}else{if(1!==t)throw new Error("Invalid type");{const t=2*e.next()+1;F.push(new y.O4(B,t)),L.push({type:"sphere",radius:t})}}}}const D=[];for(let e=0;e<4;++e)for(let t=0;t<8;++t){const n=8*e+t,r=60*(t-4)+30,i=60*(e-2)+30,s=new T.x(A,q);for(let e=0;e<q;++e){s.setShape(e,F[e]);const t=h.uq.TranslationToRef(r,1+2*e,i,E);s.setInitialTransform(e,t),s.setFriction(e,1),s.setLinearDamping(e,.3),s.setAngularDamping(e,.3)}const o=new R.Y(B,s);B.addRigidBodyBundle(o,n);for(let e=0;e<q;e+=2){const t=[e,e+1],r=new f.vC(B,o,t,h.uq.Translation(0,-1.2,0),h.uq.Translation(0,1.2,0),!0);r.setLinearLowerLimit(new h.Pq(0,0,0)),r.setLinearUpperLimit(new h.Pq(0,0,0)),r.setAngularLowerLimit(new h.Pq(Math.PI/4,0,0)),r.setAngularUpperLimit(new h.Pq(0,0,0));for(let e=0;e<6;++e)r.enableSpring(e,!0),r.setStiffness(e,100),r.setDamping(e,1);B.addConstraint(r,n,!0)}D.push(o)}console.log("Rigid body count:",16384);const W=[],G=(0,c.an)("baseBox",{size:1},n),Q=(0,u._6)("baseSphere",{diameter:1},n);G.setEnabled(!1),Q.setEnabled(!1),G.receiveShadows=!0,Q.receiveShadows=!0;for(let e=0;e<16384;++e){const t=L[e%L.length],n="box"===t.type?G.createInstance(`boxInstance${e}`):Q.createInstance(`sphereInstance${e}`);M.addShadowCaster(n),n.scaling.copyFrom("box"===t.type?t.size.scale(2):new h.Pq(t.radius,t.radius,t.radius).scale(2)),n.rotationQuaternion=h.PT.Identity(),W.push(n)}return B.onTickObservable.add((()=>{for(let e=0;e<D.length;++e){const t=D[e];for(let n=0;n<q;++n){t.getTransformMatrixToRef(n,E);const r=W[e*q+n];E.getTranslationToRef(r.position),h.PT.FromRotationMatrixToRef(E,r.rotationQuaternion)}}})),new P.X((()=>{B.afterAnimations(1/60*1e3);const e=performance.now();return n.render(),[0,performance.now()-e]})).runBench(),B.register(n),n}}},2399:(e,t,n)=>{n.d(t,{q:()=>r});class r{_a;constructor(e){this._a=e}next(){let e=this._a+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296}}},7648:(e,t,n)=>{n.d(t,{Y:()=>o});class r{_wasmInstance;_ptr;_shapeReferences;_referenceCount;_shadowCount;constructor(e,t,n){this._wasmInstance=e,this._ptr=t,this._shapeReferences=n;for(const e of n)e.addReference();this._referenceCount=0,this._shadowCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose rigid body bundle while it still has references");if(0!==this._ptr){this._wasmInstance.deref()?.destroyRigidBodyBundle(this._ptr),this._ptr=0;for(const e of this._shapeReferences)e.removeReference();this._shapeReferences.clear()}}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}addShadow(){this._shadowCount+=1}removeShadow(){this._shadowCount-=1}get hasShadows(){return 0<this._shadowCount}}function i(e){e.dispose()}const s=new WeakMap;class o{runtime;_motionStatesPtr;_bufferedMotionStatesPtr;_worldTransformPtrArray;_temporalKinematicStatesPtr;_inner;_count;_worldReference;impl;isContainsDynamic;constructor(e,t){if(0===t.ptr)throw new Error("Cannot create rigid body bundle with null pointer");const n=t.count,o=new Set;for(let r=0;r<n;++r){const n=t.getShape(r);if(null===n)throw new Error("Cannot create rigid body bundle with null shape");if(n.runtime!==e)throw new Error("Cannot create rigid body bundle with shapes from different runtimes");o.add(n)}this.runtime=e;const a=e.wasmInstance,h=a.createRigidBodyBundle(t.ptr,n),c=a.rigidBodyBundleGetMotionStatesPtr(h);this._motionStatesPtr=a.createTypedArray(Float32Array,c,20*n);const l=a.rigidBodyBundleGetBufferedMotionStatesPtr(h);this._bufferedMotionStatesPtr=a.createTypedArray(Float32Array,l,20*n);const u=[];let d=!1;for(let e=0;e<n;++e)if(0===t.getMotionType(e)){d=!0;const t=a.rigidBodyBundleGetWorldTransformPtr(h,e);u.push(a.createTypedArray(Float32Array,t,16))}else u.push(null);this._worldTransformPtrArray=u;const m=a.rigidBodyBundleGetTemporalKinematicStatesPtr(h);this._temporalKinematicStatesPtr=a.createTypedArray(Uint8Array,m,n),this._inner=new r(new WeakRef(e.wasmInstance),h,o),this._count=n,this._worldReference=null;let f=s.get(a);void 0===f&&(f=new FinalizationRegistry(i),s.set(a,f)),f.register(this,this._inner,this),this.impl=e.createRigidBodyBundleImpl(this),this.isContainsDynamic=d}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}get count(){return this._count}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}addShadowReference(){this._inner.addShadow()}removeShadowReference(){this._inner.removeShadow()}get hasShadows(){return this._inner.hasShadows}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add rigid body bundle to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}getWorldReference(){return this._worldReference}updateBufferedMotionStates(e){if(this._nullCheck(),e){const e=this.runtime.wasmInstance.rigidBodyBundleGetMotionStatesPtr(this._inner.ptr);this._bufferedMotionStatesPtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20*this._count)}else{const e=this.runtime.wasmInstance.rigidBodyBundleGetBufferedMotionStatesPtr(this._inner.ptr);this._bufferedMotionStatesPtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20*this._count)}}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed rigid body bundle")}getTransformMatrixToRef(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const n=this._bufferedMotionStatesPtr.array,r=20*e;return t.set(n[r+4+0],n[r+8+0],n[r+12+0],0,n[r+4+1],n[r+8+1],n[r+12+1],0,n[r+4+2],n[r+8+2],n[r+12+2],0,n[r+16+0],n[r+16+1],n[r+16+2],1)}getTransformMatrixToArray(e,t,n=0){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatesPtr.array,i=20*e;t[n+0]=r[i+4+0],t[n+1]=r[i+8+0],t[n+2]=r[i+12+0],t[n+3]=0,t[n+4]=r[i+4+1],t[n+5]=r[i+8+1],t[n+6]=r[i+12+1],t[n+7]=0,t[n+8]=r[i+4+2],t[n+9]=r[i+8+2],t[n+10]=r[i+12+2],t[n+11]=0,t[n+12]=r[i+16+0],t[n+13]=r[i+16+1],t[n+14]=r[i+16+2],t[n+15]=1}getTransformMatricesToArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const n=this._bufferedMotionStatesPtr.array,r=this._count;let i=0,s=t;for(let t=0;t<r;++t)e[s+0]=n[i+4+0],e[s+1]=n[i+8+0],e[s+2]=n[i+12+0],e[s+3]=0,e[s+4]=n[i+4+1],e[s+5]=n[i+8+1],e[s+6]=n[i+12+1],e[s+7]=0,e[s+8]=n[i+4+2],e[s+9]=n[i+8+2],e[s+10]=n[i+12+2],e[s+11]=0,e[s+12]=n[i+16+0],e[s+13]=n[i+16+1],e[s+14]=n[i+16+2],e[s+15]=1,i+=20,s+=16}setTransformMatrix(e,t){this.setTransformMatrixFromArray(e,t.m,0)}setTransformMatrixFromArray(e,t,n=0){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatrixFromArray(this._motionStatesPtr,this._temporalKinematicStatesPtr,e,t,n)}setTransformMatricesFromArray(e,t=0){if(this._nullCheck(),e.length<16*this._count)throw new RangeError("Array is too short");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatricesFromArray(this._motionStatesPtr,this._temporalKinematicStatesPtr,e,t)}setDynamicTransformMatrix(e){this.setTransformMatricesFromArray(e.m,0)}setDynamicTransformMatrixFromArray(e,t,n=0){if(null===this._worldTransformPtrArray[e])throw new Error("Cannot set dynamic transform of non-dynamic body");if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setDynamicTransformMatrixFromArray(this._worldTransformPtrArray,e,t,n)}setDamping(e,t,n){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setDamping(this.runtime.wasmInstance,this._inner.ptr,e,t,n)}getLinearDamping(e){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");return this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.getLinearDamping(this.runtime.wasmInstance,this._inner.ptr,e)}getAngularDamping(e){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");return this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.getAngularDamping(this.runtime.wasmInstance,this._inner.ptr,e)}setMassProps(e,t,n){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setMassProps(this.runtime.wasmInstance,this._inner.ptr,e,t,n)}getMass(e){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");return this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.getMass(this.runtime.wasmInstance,this._inner.ptr,e)}getLocalInertia(e){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");return this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.getLocalInertia(this.runtime.wasmInstance,this._inner.ptr,e)}translate(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.translate(this.runtime.wasmInstance,this._inner.ptr,e,t)}get needToCommit(){return this.impl.needToCommit??!1}commitToWasm(){if(void 0===this.impl.commitToWasm)throw new Error("commit only avalible on buffered evaluation mode");this._nullCheck(),this.runtime.lock.wait(),this.impl.commitToWasm(this.runtime.wasmInstance,this._inner.ptr,this._motionStatesPtr,this._temporalKinematicStatesPtr,this._worldTransformPtrArray)}}}}]);