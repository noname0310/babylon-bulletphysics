"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[9013],{472:(e,t,n)=>{n.d(t,{y:()=>a});class r{_runtime;_ptr;_rigidBodyReferences;_rigidBodyBundleReferences;_constraintReferences;_referenceCount;constructor(e,t){this._runtime=e,this._ptr=t,this._rigidBodyReferences=new Set,this._rigidBodyBundleReferences=new Set,this._constraintReferences=new Set,this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose physics world while it still has references");if(0===this._ptr)return;const e=this._runtime.deref();void 0!==e&&(e.lock.wait(),e.wasmInstance.destroyPhysicsWorld(this._ptr)),this._ptr=0;for(const e of this._rigidBodyReferences)e.setWorldReference(null);this._rigidBodyReferences.clear();for(const e of this._rigidBodyBundleReferences)e.setWorldReference(null);this._rigidBodyBundleReferences.clear();for(const e of this._constraintReferences)e.setWorldReference(null);this._constraintReferences.clear()}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}addRigidBodyReference(e){return!this._rigidBodyReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyReferences.add(e),!0)}removeRigidBodyReference(e){return!!this._rigidBodyReferences.delete(e)&&(e.setWorldReference(null),!0)}addRigidBodyBundleReference(e){return!this._rigidBodyBundleReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyBundleReferences.add(e),!0)}removeRigidBodyBundleReference(e){return!!this._rigidBodyBundleReferences.delete(e)&&(e.setWorldReference(null),!0)}addConstraintReference(e){return!this._constraintReferences.has(e)&&(e.setWorldReference(this),this._constraintReferences.add(e),!0)}removeConstraintReference(e){return!!this._constraintReferences.delete(e)&&(e.setWorldReference(null),!0)}}function i(e){e.dispose()}const s=new WeakMap;class a{_runtime;_inner;constructor(e){this._runtime=e;const t=e.wasmInstance.createPhysicsWorld();this._inner=new r(new WeakRef(e),t);let n=s.get(e.wasmInstance);void 0===n&&(n=new FinalizationRegistry(i),s.set(e.wasmInstance,n)),n.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this._runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed physics world")}setGravity(e){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldSetGravity(this._inner.ptr,e.x,e.y,e.z)}stepSimulation(e,t,n){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldStepSimulation(this._inner.ptr,e,t,n)}addRigidBody(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body from different runtime");return this._nullCheck(),!!this._inner.addRigidBodyReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddRigidBody(this._inner.ptr,e.ptr),!0)}removeRigidBody(e){return this._nullCheck(),!!this._inner.removeRigidBodyReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveRigidBody(this._inner.ptr,e.ptr),!0)}addRigidBodyBundle(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body bundle from different runtime");return this._nullCheck(),!!this._inner.addRigidBodyBundleReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddRigidBodyBundle(this._inner.ptr,e.ptr),!0)}removeRigidBodyBundle(e){return this._nullCheck(),!!this._inner.removeRigidBodyBundleReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveRigidBodyBundle(this._inner.ptr,e.ptr),!0)}addConstraint(e,t){if(e.runtime!==this._runtime)throw new Error("Cannot add constraint from different runtime");return this._nullCheck(),!!this._inner.addConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddConstraint(this._inner.ptr,e.ptr,t),!0)}removeConstraint(e){return this._nullCheck(),!!this._inner.removeConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveConstraint(this._inner.ptr,e.ptr),!0)}}},2090:(e,t,n)=>{n.d(t,{D:()=>a});var r=n(5228),i=n(4444);class s{wait(){}}class a{wasmInstance;lock;constructor(e){this.wasmInstance=e,this.lock=new s}createRigidBodyImpl(){return new i.x}createRigidBodyBundleImpl(e){return new r.R(e.count)}}},7168:(e,t,n)=>{n.d(t,{o6:()=>c,vC:()=>d});class r{_wasmInstance;_ptr;_bodyReference;_referenceCount;constructor(e,t,n){this._wasmInstance=e,this._ptr=t,this._bodyReference=n,Array.isArray(n)?(n[0].addReference(),n[1].addReference()):n.addReference(),this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose constraint while it still has references");0!==this._ptr&&(this._wasmInstance.deref()?.destroyConstraint(this._ptr),this._ptr=0,Array.isArray(this._bodyReference)?(this._bodyReference[0].removeReference(),this._bodyReference[1].removeReference()):this._bodyReference.removeReference(),this._bodyReference=null)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}}function i(e){e.dispose()}const s=new WeakMap;class a{runtime;_inner;_worldReference;constructor(e,t,n){if(Array.isArray(n)){if(n[0].runtime!==e||n[1].runtime!==e)throw new Error("Cannot create constraint between bodies from different runtimes")}else if(n.runtime!==e)throw new Error("Cannot create constraint between body and bundle from different runtimes");this.runtime=e,this._inner=new r(new WeakRef(e.wasmInstance),t,n),this._worldReference=null;let a=s.get(e.wasmInstance);void 0===a&&(a=new FinalizationRegistry(i),s.set(e.wasmInstance,a)),a.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add constraint to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}}const o=64;class c extends a{constructor(e,t,n,r,i,s){const a=e.wasmInstance,c=a.allocateBuffer(o),d=a.createTypedArray(Float32Array,c,16);r.copyToArray(d.array);const h=a.allocateBuffer(o),l=a.createTypedArray(Float32Array,h,16);i.copyToArray(l.array);const u=Array.isArray(n),f=u?a.createGeneric6DofConstraintFromBundle(t.ptr,n[0],n[1],c,h,s):a.createGeneric6DofConstraint(t.ptr,n.ptr,c,h,s);a.deallocateBuffer(c,o),a.deallocateBuffer(h,o),super(e,f,u?t:[t,n])}setLinearLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setLinearUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearUpperLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularUpperLimit(this._inner.ptr,e.x,e.y,e.z)}}class d extends a{constructor(e,t,n,r,i,s){const a=e.wasmInstance,c=a.allocateBuffer(o),d=a.createTypedArray(Float32Array,c,16);r.copyToArray(d.array);const h=a.allocateBuffer(o),l=a.createTypedArray(Float32Array,h,16);i.copyToArray(l.array);const u=Array.isArray(n),f=u?a.createGeneric6DofSpringConstraintFromBundle(t.ptr,n[0],n[1],c,h,s):a.createGeneric6DofSpringConstraint(t.ptr,n.ptr,c,h,s);a.deallocateBuffer(c,o),a.deallocateBuffer(h,o),super(e,f,u?t:[t,n])}setLinearLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setLinearUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearUpperLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularUpperLimit(this._inner.ptr,e.x,e.y,e.z)}enableSpring(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintEnableSpring(this._inner.ptr,e,t)}setStiffness(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetStiffness(this._inner.ptr,e,t)}setDamping(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetDamping(this._inner.ptr,e,t)}}},9013:(e,t,n)=>{n.r(t),n.d(t,{SceneBuilder:()=>C}),n(203),n(1503),n(8227);var r=n(7456),i=n(5581),s=n(1513),a=n(9711),o=n(6041),c=n(9923),d=n(9899),h=n(8144),l=n(554),u=n(6738),f=n(7168),m=n(2090),w=n(7002),_=n(6405),p=n(472),y=n(1592),R=n(7648),g=n(5901),B=n(3477);class C{async build(e,t){const n=new l.Z(t);n.clearColor=new o.ov(.95,.95,.95,1);const C=new r.Lq("arcRotateCamera",0,0,500,new c.Pq(0,0,0),n);C.minZ=1,C.maxZ=1e3,C.setPosition(new c.Pq(60,40,-50)),C.attachControl(void 0,!1),C.inertia=.8,C.speed=10;const L=new s.g("hemisphericLight",new c.Pq(0,1,0),n);L.intensity=.5,L.specular=new o.v9(0,0,0),L.groundColor=new o.v9(1,1,1);const I=new i.Z("directionalLight",new c.Pq(.5,-1,1),n);I.intensity=.5;I.shadowMaxZ=60,I.shadowMinZ=-60,I.autoCalcShadowZBounds=!1,I.autoUpdateExtends=!1,I.shadowOrthoScale=0,I.orthoTop=60,I.orthoBottom=-60,I.orthoLeft=-60,I.orthoRight=60;const A=new a.o(2048,I,!0);A.transparencyShadow=!0,A.usePercentageCloserFiltering=!0,A.forceBackFacesOnly=!1,A.bias=.004,A.filteringQuality=a.o.QUALITY_MEDIUM;const k=await(0,u.e)(new w.t),v=new m.D(k),S=new p.y(v),b=new c.uq;{const e=(0,h.x)("ground",{size:120},n);e.rotationQuaternion=c.PT.RotationAxis(new c.Pq(1,0,0),Math.PI/2),A.addShadowCaster(e),e.receiveShadows=!0;const t=new _.Ty(v,new c.Pq(0,0,-1),0),r=new g.t(k);r.shape=t,c.uq.FromQuaternionToRef(e.rotationQuaternion,b),r.setInitialTransform(b),r.motionType=1;const i=new y.U(v,r);S.addRigidBody(i)}const W=1024,T=(0,d.an)("box",{size:2},n);A.addShadowCaster(T),T.receiveShadows=!0;const x=new Float32Array(16384);T.thinInstanceSetBuffer("matrix",x,16,!1);const P=new _.SA(v,new c.Pq(1,1,1)),q=new B.x(k,W);for(let e=0;e<W;++e){q.setShape(e,P);const t=c.uq.TranslationToRef(0,1+2*e,0,b);q.setInitialTransform(e,t),q.setFriction(e,1),q.setLinearDamping(e,.3),q.setAngularDamping(e,.3)}const U=new R.Y(v,q);S.addRigidBodyBundle(U);for(let e=0;e<W;e+=2){const t=[e,e+1],n=new f.vC(v,U,t,c.uq.Translation(0,-1.2,0),c.uq.Translation(0,1.2,0),!0);n.setLinearLowerLimit(new c.Pq(0,0,0)),n.setLinearUpperLimit(new c.Pq(0,0,0)),n.setAngularLowerLimit(new c.Pq(Math.PI/4,0,0)),n.setAngularUpperLimit(new c.Pq(0,0,0));for(let e=0;e<6;++e)n.enableSpring(e,!0),n.setStiffness(e,100),n.setDamping(e,1);S.addConstraint(n,!1)}return n.onBeforeRenderObservable.add((()=>{S.stepSimulation(1/60,10,1/60),U.getTransformMatricesToArray(x),T.thinInstanceBufferUpdated("matrix")})),n}}}}]);