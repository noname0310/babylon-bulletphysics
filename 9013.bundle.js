"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[9013],{2090:(e,t,r)=>{r.d(t,{D:()=>o});var n=r(5228),i=r(94444);class s{wait(){}}class o{wasmInstance;lock;constructor(e){this.wasmInstance=e,this.lock=new s}createRigidBodyImpl(){return new i.x}createRigidBodyBundleImpl(e){return new n.R(e.count)}}},80472:(e,t,r)=>{r.d(t,{y:()=>o});class n{_runtime;_ptr;_rigidBodyReferences;_rigidBodyBundleReferences;_constraintReferences;_referenceCount;constructor(e,t){this._runtime=e,this._ptr=t,this._rigidBodyReferences=new Set,this._rigidBodyBundleReferences=new Set,this._constraintReferences=new Set,this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose physics world while it still has references");if(0===this._ptr)return;const e=this._runtime.deref();void 0!==e&&(e.lock.wait(),e.wasmInstance.destroyPhysicsWorld(this._ptr)),this._ptr=0;for(const e of this._rigidBodyReferences)e.setWorldReference(null);this._rigidBodyReferences.clear();for(const e of this._rigidBodyBundleReferences)e.setWorldReference(null);this._rigidBodyBundleReferences.clear();for(const e of this._constraintReferences)e.setWorldReference(null);this._constraintReferences.clear()}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}addRigidBodyReference(e){return!this._rigidBodyReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyReferences.add(e),!0)}removeRigidBodyReference(e){return!!this._rigidBodyReferences.delete(e)&&(e.setWorldReference(null),!0)}addRigidBodyBundleReference(e){return!this._rigidBodyBundleReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyBundleReferences.add(e),!0)}removeRigidBodyBundleReference(e){return!!this._rigidBodyBundleReferences.delete(e)&&(e.setWorldReference(null),!0)}addConstraintReference(e){return!this._constraintReferences.has(e)&&(e.setWorldReference(this),this._constraintReferences.add(e),!0)}removeConstraintReference(e){return!!this._constraintReferences.delete(e)&&(e.setWorldReference(null),!0)}}function i(e){e.dispose()}const s=new WeakMap;class o{_runtime;_inner;constructor(e){this._runtime=e;const t=e.wasmInstance.createPhysicsWorld();this._inner=new n(new WeakRef(e),t);let r=s.get(e.wasmInstance);void 0===r&&(r=new FinalizationRegistry(i),s.set(e.wasmInstance,r)),r.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this._runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed physics world")}setGravity(e){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldSetGravity(this._inner.ptr,e.x,e.y,e.z)}stepSimulation(e,t,r){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldStepSimulation(this._inner.ptr,e,t,r)}addRigidBody(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body from different runtime");return this._nullCheck(),!!this._inner.addRigidBodyReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddRigidBody(this._inner.ptr,e.ptr),!0)}removeRigidBody(e){return this._nullCheck(),!!this._inner.removeRigidBodyReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveRigidBody(this._inner.ptr,e.ptr),!0)}addRigidBodyBundle(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body bundle from different runtime");return this._nullCheck(),!!this._inner.addRigidBodyBundleReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddRigidBodyBundle(this._inner.ptr,e.ptr),!0)}removeRigidBodyBundle(e){return this._nullCheck(),!!this._inner.removeRigidBodyBundleReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveRigidBodyBundle(this._inner.ptr,e.ptr),!0)}addConstraint(e,t){if(e.runtime!==this._runtime)throw new Error("Cannot add constraint from different runtime");return this._nullCheck(),!!this._inner.addConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddConstraint(this._inner.ptr,e.ptr,t),!0)}removeConstraint(e){return this._nullCheck(),!!this._inner.removeConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveConstraint(this._inner.ptr,e.ptr),!0)}}},67648:(e,t,r)=>{r.d(t,{Y:()=>o});class n{_wasmInstance;_ptr;_shapeReferences;_referenceCount;_shadowCount;constructor(e,t,r){this._wasmInstance=e,this._ptr=t,this._shapeReferences=r;for(const e of r)e.addReference();this._referenceCount=0,this._shadowCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose rigid body bundle while it still has references");if(0!==this._ptr){this._wasmInstance.deref()?.destroyRigidBodyBundle(this._ptr),this._ptr=0;for(const e of this._shapeReferences)e.removeReference();this._shapeReferences.clear()}}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}addShadow(){this._shadowCount+=1}removeShadow(){this._shadowCount-=1}get hasShadows(){return 0<this._shadowCount}}function i(e){e.dispose()}const s=new WeakMap;class o{runtime;_motionStatesPtr;_bufferedMotionStatesPtr;_worldTransformPtrArray;_temporalKinematicStatesPtr;_inner;_count;_worldReference;impl;isContainsDynamic;constructor(e,t){if(0===t.ptr)throw new Error("Cannot create rigid body bundle with null pointer");const r=t.count,o=new Set;for(let n=0;n<r;++n){const r=t.getShape(n);if(null===r)throw new Error("Cannot create rigid body bundle with null shape");if(r.runtime!==e)throw new Error("Cannot create rigid body bundle with shapes from different runtimes");o.add(r)}this.runtime=e;const a=e.wasmInstance,d=a.createRigidBodyBundle(t.ptr,r),h=a.rigidBodyBundleGetMotionStatesPtr(d);this._motionStatesPtr=a.createTypedArray(Float32Array,h,20*r);const c=a.rigidBodyBundleGetBufferedMotionStatesPtr(d);this._bufferedMotionStatesPtr=a.createTypedArray(Float32Array,c,20*r);const l=[];let u=!1;for(let e=0;e<r;++e)if(0===t.getMotionType(e)){u=!0;const t=a.rigidBodyBundleGetWorldTransformPtr(d,e);l.push(a.createTypedArray(Float32Array,t,16))}else l.push(null);this._worldTransformPtrArray=l;const f=a.rigidBodyBundleGetTemporalKinematicStatesPtr(d);this._temporalKinematicStatesPtr=a.createTypedArray(Uint8Array,f,r),this._inner=new n(new WeakRef(e.wasmInstance),d,o),this._count=r,this._worldReference=null;let m=s.get(a);void 0===m&&(m=new FinalizationRegistry(i),s.set(a,m)),m.register(this,this._inner,this),this.impl=e.createRigidBodyBundleImpl(this),this.isContainsDynamic=u}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}get count(){return this._count}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}addShadowReference(){this._inner.addShadow()}removeShadowReference(){this._inner.removeShadow()}get hasShadows(){return this._inner.hasShadows}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add rigid body bundle to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}getWorldReference(){return this._worldReference}updateBufferedMotionStates(e){if(this._nullCheck(),e){const e=this.runtime.wasmInstance.rigidBodyBundleGetMotionStatesPtr(this._inner.ptr);this._bufferedMotionStatesPtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20*this._count)}else{const e=this.runtime.wasmInstance.rigidBodyBundleGetBufferedMotionStatesPtr(this._inner.ptr);this._bufferedMotionStatesPtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20*this._count)}}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed rigid body bundle")}getTransformMatrixToRef(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatesPtr.array,n=20*e;return t.set(r[n+4+0],r[n+8+0],r[n+12+0],0,r[n+4+1],r[n+8+1],r[n+12+1],0,r[n+4+2],r[n+8+2],r[n+12+2],0,r[n+16+0],r[n+16+1],r[n+16+2],1)}getTransformMatrixToArray(e,t,r=0){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const n=this._bufferedMotionStatesPtr.array,i=20*e;t[r+0]=n[i+4+0],t[r+1]=n[i+8+0],t[r+2]=n[i+12+0],t[r+3]=0,t[r+4]=n[i+4+1],t[r+5]=n[i+8+1],t[r+6]=n[i+12+1],t[r+7]=0,t[r+8]=n[i+4+2],t[r+9]=n[i+8+2],t[r+10]=n[i+12+2],t[r+11]=0,t[r+12]=n[i+16+0],t[r+13]=n[i+16+1],t[r+14]=n[i+16+2],t[r+15]=1}getTransformMatricesToArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatesPtr.array,n=this._count;let i=0,s=t;for(let t=0;t<n;++t)e[s+0]=r[i+4+0],e[s+1]=r[i+8+0],e[s+2]=r[i+12+0],e[s+3]=0,e[s+4]=r[i+4+1],e[s+5]=r[i+8+1],e[s+6]=r[i+12+1],e[s+7]=0,e[s+8]=r[i+4+2],e[s+9]=r[i+8+2],e[s+10]=r[i+12+2],e[s+11]=0,e[s+12]=r[i+16+0],e[s+13]=r[i+16+1],e[s+14]=r[i+16+2],e[s+15]=1,i+=20,s+=16}setTransformMatrix(e,t){this.setTransformMatrixFromArray(e,t.m,0)}setTransformMatrixFromArray(e,t,r=0){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatrixFromArray(this._motionStatesPtr,this._temporalKinematicStatesPtr,e,t,r)}setTransformMatricesFromArray(e,t=0){if(this._nullCheck(),e.length<16*this._count)throw new RangeError("Array is too short");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatricesFromArray(this._motionStatesPtr,this._temporalKinematicStatesPtr,e,t)}setDynamicTransformMatrix(e){this.setTransformMatricesFromArray(e.m,0)}setDynamicTransformMatrixFromArray(e,t,r=0){if(null===this._worldTransformPtrArray[e])throw new Error("Cannot set dynamic transform of non-dynamic body");if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setDynamicTransformMatrixFromArray(this._worldTransformPtrArray,e,t,r)}get needToCommit(){return this.impl.needToCommit??!1}commitToWasm(){if(void 0===this.impl.commitToWasm)throw new Error("commit only avalible on buffered evaluation mode");this._nullCheck(),this.runtime.lock.wait(),this.impl.commitToWasm(this.runtime.wasmInstance,this._inner.ptr,this._motionStatesPtr,this._temporalKinematicStatesPtr,this._worldTransformPtrArray)}}},29013:(e,t,r)=>{r.r(t),r.d(t,{SceneBuilder:()=>C}),r(90203),r(33832),r(2093);var n=r(7839),i=r(52046),s=r(71513),o=r(18595),a=r(26041),d=r(79923),h=r(96793),c=r(58144),l=r(87491),u=r(46738),f=r(67168),m=r(2090),_=r(47002),w=r(26405),y=r(80472),p=r(1592),R=r(67648),g=r(35901),B=r(3477);class C{async build(e,t){const r=new l.Z(t);r.clearColor=new a.ov(.95,.95,.95,1);const C=new n.L("arcRotateCamera",0,0,500,new d.Pq(0,0,0),r);C.minZ=1,C.maxZ=1e3,C.setPosition(new d.Pq(60,40,-50)),C.attachControl(void 0,!1),C.inertia=.8,C.speed=10;const S=new s.g("hemisphericLight",new d.Pq(0,1,0),r);S.intensity=.5,S.specular=new a.v9(0,0,0),S.groundColor=new a.v9(1,1,1);const T=new i.Z("directionalLight",new d.Pq(.5,-1,1),r);T.intensity=.5;T.shadowMaxZ=60,T.shadowMinZ=-60,T.autoCalcShadowZBounds=!1,T.autoUpdateExtends=!1,T.shadowOrthoScale=0,T.orthoTop=60,T.orthoBottom=-60,T.orthoLeft=-60,T.orthoRight=60;const P=new o.o(2048,T,!0);P.transparencyShadow=!0,P.usePercentageCloserFiltering=!0,P.forceBackFacesOnly=!1,P.bias=.004,P.filteringQuality=o.o.QUALITY_MEDIUM;const k=await(0,u.e)(new _.t),v=new m.D(k),I=new y.y(v),b=new d.uq;{const e=(0,c.x)("ground",{size:120},r);e.rotationQuaternion=d.PT.RotationAxis(new d.Pq(1,0,0),Math.PI/2),P.addShadowCaster(e),e.receiveShadows=!0;const t=new w.Ty(v,new d.Pq(0,0,-1),0),n=new g.t(k);n.shape=t,d.uq.FromQuaternionToRef(e.rotationQuaternion,b),n.setInitialTransform(b),n.motionType=1;const i=new p.U(v,n);I.addRigidBody(i)}const A=1024,M=(0,h.an)("box",{size:2},r);P.addShadowCaster(M),M.receiveShadows=!0;const W=new Float32Array(16384);M.thinInstanceSetBuffer("matrix",W,16,!1);const x=new w.SA(v,new d.Pq(1,1,1)),E=new B.x(k,A);for(let e=0;e<A;++e){E.setShape(e,x);const t=d.uq.TranslationToRef(0,1+2*e,0,b);E.setInitialTransform(e,t),E.setFriction(e,1),E.setLinearDamping(e,.3),E.setAngularDamping(e,.3)}const F=new R.Y(v,E);I.addRigidBodyBundle(F);for(let e=0;e<A;e+=2){const t=[e,e+1],r=new f.vC(v,F,t,d.uq.Translation(0,-1.2,0),d.uq.Translation(0,1.2,0),!0);r.setLinearLowerLimit(new d.Pq(0,0,0)),r.setLinearUpperLimit(new d.Pq(0,0,0)),r.setAngularLowerLimit(new d.Pq(Math.PI/4,0,0)),r.setAngularUpperLimit(new d.Pq(0,0,0));for(let e=0;e<6;++e)r.enableSpring(e,!0),r.setStiffness(e,100),r.setDamping(e,1);I.addConstraint(r,!1)}return r.onBeforeRenderObservable.add((()=>{I.stepSimulation(1/60,10,1/60),F.getTransformMatricesToArray(W),M.thinInstanceBufferUpdated("matrix")})),r}}}}]);