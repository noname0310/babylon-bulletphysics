"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[9013],{472:(e,n,t)=>{t.d(n,{y:()=>o});class r{_runtime;_ptr;_rigidBodyReferences;_rigidBodyBundleReferences;_constraintReferences;_referenceCount;constructor(e,n){this._runtime=e,this._ptr=n,this._rigidBodyReferences=new Set,this._rigidBodyBundleReferences=new Set,this._constraintReferences=new Set,this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose physics world while it still has references");if(0===this._ptr)return;const e=this._runtime.deref();void 0!==e&&(e.lock.wait(),e.wasmInstance.destroyPhysicsWorld(this._ptr)),this._ptr=0;for(const e of this._rigidBodyReferences)e.setWorldReference(null);this._rigidBodyReferences.clear();for(const e of this._rigidBodyBundleReferences)e.setWorldReference(null);this._rigidBodyBundleReferences.clear();for(const e of this._constraintReferences)e.setWorldReference(null);this._constraintReferences.clear()}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}addRigidBodyReference(e){return!this._rigidBodyReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyReferences.add(e),!0)}removeRigidBodyReference(e){return!!this._rigidBodyReferences.delete(e)&&(e.setWorldReference(null),!0)}addRigidBodyBundleReference(e){return!this._rigidBodyBundleReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyBundleReferences.add(e),!0)}removeRigidBodyBundleReference(e){return!!this._rigidBodyBundleReferences.delete(e)&&(e.setWorldReference(null),!0)}addConstraintReference(e){return!this._constraintReferences.has(e)&&(e.setWorldReference(this),this._constraintReferences.add(e),!0)}removeConstraintReference(e){return!!this._constraintReferences.delete(e)&&(e.setWorldReference(null),!0)}}function i(e){e.dispose()}const s=new WeakMap;class o{_runtime;_inner;constructor(e){this._runtime=e;const n=e.wasmInstance.createPhysicsWorld();this._inner=new r(new WeakRef(e),n);let t=s.get(e.wasmInstance);void 0===t&&(t=new FinalizationRegistry(i),s.set(e.wasmInstance,t)),t.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this._runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed physics world")}setGravity(e){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldSetGravity(this._inner.ptr,e.x,e.y,e.z)}stepSimulation(e,n,t){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldStepSimulation(this._inner.ptr,e,n,t)}addRigidBody(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body from different runtime");return this._nullCheck(),!!this._inner.addRigidBodyReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddRigidBody(this._inner.ptr,e.ptr),!0)}removeRigidBody(e){return this._nullCheck(),!!this._inner.removeRigidBodyReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveRigidBody(this._inner.ptr,e.ptr),!0)}addRigidBodyBundle(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body bundle from different runtime");return this._nullCheck(),!!this._inner.addRigidBodyBundleReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddRigidBodyBundle(this._inner.ptr,e.ptr),!0)}removeRigidBodyBundle(e){return this._nullCheck(),!!this._inner.removeRigidBodyBundleReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveRigidBodyBundle(this._inner.ptr,e.ptr),!0)}addConstraint(e,n){if(e.runtime!==this._runtime)throw new Error("Cannot add constraint from different runtime");return this._nullCheck(),!!this._inner.addConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddConstraint(this._inner.ptr,e.ptr,n),!0)}removeConstraint(e){return this._nullCheck(),!!this._inner.removeConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveConstraint(this._inner.ptr,e.ptr),!0)}}},2090:(e,n,t)=>{t.d(n,{D:()=>o});var r=t(5228),i=t(4444);class s{wait(){}}class o{wasmInstance;lock;constructor(e){this.wasmInstance=e,this.lock=new s}createRigidBodyImpl(){return new i.x}createRigidBodyBundleImpl(e){return new r.R(e.count)}}},7168:(e,n,t)=>{t.d(n,{o6:()=>d,vC:()=>h});class r{_wasmInstance;_ptr;_bodyReference;_referenceCount;constructor(e,n,t){this._wasmInstance=e,this._ptr=n,this._bodyReference=t,Array.isArray(t)?(t[0].addReference(),t[1].addReference()):t.addReference(),this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose constraint while it still has references");0!==this._ptr&&(this._wasmInstance.deref()?.destroyConstraint(this._ptr),this._ptr=0,Array.isArray(this._bodyReference)?(this._bodyReference[0].removeReference(),this._bodyReference[1].removeReference()):this._bodyReference.removeReference(),this._bodyReference=null)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}}function i(e){e.dispose()}const s=new WeakMap;class o{runtime;_inner;_worldReference;constructor(e,n,t){if(Array.isArray(t)){if(t[0].runtime!==e||t[1].runtime!==e)throw new Error("Cannot create constraint between bodies from different runtimes")}else if(t.runtime!==e)throw new Error("Cannot create constraint between body and bundle from different runtimes");this.runtime=e,this._inner=new r(new WeakRef(e.wasmInstance),n,t),this._worldReference=null;let o=s.get(e.wasmInstance);void 0===o&&(o=new FinalizationRegistry(i),s.set(e.wasmInstance,o)),o.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add constraint to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}}const a=64;class c extends o{setLinearLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setLinearUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearUpperLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularUpperLimit(this._inner.ptr,e.x,e.y,e.z)}}class d extends c{constructor(e,n,t,r,i,s){const o=e.wasmInstance,c=o.allocateBuffer(a),d=o.createTypedArray(Float32Array,c,16);r.copyToArray(d.array);const h=o.allocateBuffer(a),l=o.createTypedArray(Float32Array,h,16);i.copyToArray(l.array);const u=Array.isArray(t),f=u?o.createGeneric6DofConstraintFromBundle(n.ptr,t[0],t[1],c,h,s):o.createGeneric6DofConstraint(n.ptr,t.ptr,c,h,s);o.deallocateBuffer(c,a),o.deallocateBuffer(h,a),super(e,f,u?n:[n,t])}}class h extends c{constructor(e,n,t,r,i,s){const o=e.wasmInstance,c=o.allocateBuffer(a),d=o.createTypedArray(Float32Array,c,16);r.copyToArray(d.array);const h=o.allocateBuffer(a),l=o.createTypedArray(Float32Array,h,16);i.copyToArray(l.array);const u=Array.isArray(t),f=u?o.createGeneric6DofSpringConstraintFromBundle(n.ptr,t[0],t[1],c,h,s):o.createGeneric6DofSpringConstraint(n.ptr,t.ptr,c,h,s);o.deallocateBuffer(c,a),o.deallocateBuffer(h,a),super(e,f,u?n:[n,t])}enableSpring(e,n){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintEnableSpring(this._inner.ptr,e,n)}setStiffness(e,n){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetStiffness(this._inner.ptr,e,n)}setDamping(e,n){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetDamping(this._inner.ptr,e,n)}}},9013:(e,n,t)=>{t.r(n),t.d(n,{SceneBuilder:()=>C}),t(203),t(1503),t(8227);var r=t(7456),i=t(5581),s=t(1513),o=t(9711),a=t(6041),c=t(9923),d=t(9899),h=t(8144),l=t(554),u=t(6738),f=t(7168),m=t(2090),_=t(7002),w=t(6405),p=t(472),y=t(1592),R=t(7648),g=t(5901),B=t(3477);class C{async build(e,n){const t=new l.Z(n);t.clearColor=new a.ov(.95,.95,.95,1);const C=new r.Lq("arcRotateCamera",0,0,500,new c.Pq(0,0,0),t);C.minZ=1,C.maxZ=1e3,C.setPosition(new c.Pq(60,40,-50)),C.attachControl(void 0,!1),C.inertia=.8,C.speed=10;const I=new s.g("hemisphericLight",new c.Pq(0,1,0),t);I.intensity=.5,I.specular=new a.v9(0,0,0),I.groundColor=new a.v9(1,1,1);const v=new i.Z("directionalLight",new c.Pq(.5,-1,1),t);v.intensity=.5;v.shadowMaxZ=60,v.shadowMinZ=-60,v.autoCalcShadowZBounds=!1,v.autoUpdateExtends=!1,v.shadowOrthoScale=0,v.orthoTop=60,v.orthoBottom=-60,v.orthoLeft=-60,v.orthoRight=60;const A=new o.o(2048,v,!0);A.transparencyShadow=!0,A.usePercentageCloserFiltering=!0,A.forceBackFacesOnly=!1,A.bias=.004,A.filteringQuality=o.o.QUALITY_MEDIUM;const k=await(0,u.e)(new _.t),S=new m.D(k),b=new p.y(S),L=new c.uq;{const e=(0,h.x)("ground",{size:120},t);e.rotationQuaternion=c.PT.RotationAxis(new c.Pq(1,0,0),Math.PI/2),A.addShadowCaster(e),e.receiveShadows=!0;const n=new w.Ty(S,new c.Pq(0,0,-1),0),r=new g.t(k);r.shape=n,c.uq.FromQuaternionToRef(e.rotationQuaternion,L),r.setInitialTransform(L),r.motionType=1;const i=new y.U(S,r);b.addRigidBody(i)}const W=1024,T=(0,d.an)("box",{size:2},t);A.addShadowCaster(T),T.receiveShadows=!0;const x=new Float32Array(16384);T.thinInstanceSetBuffer("matrix",x,16,!1);const P=new w.SA(S,new c.Pq(1,1,1)),q=new B.x(k,W);for(let e=0;e<W;++e){q.setShape(e,P);const n=c.uq.TranslationToRef(0,1+2*e,0,L);q.setInitialTransform(e,n),q.setFriction(e,1),q.setLinearDamping(e,.3),q.setAngularDamping(e,.3)}const F=new R.Y(S,q);b.addRigidBodyBundle(F);for(let e=0;e<W;e+=2){const n=[e,e+1],t=new f.vC(S,F,n,c.uq.Translation(0,-1.2,0),c.uq.Translation(0,1.2,0),!0);t.setLinearLowerLimit(new c.Pq(0,0,0)),t.setLinearUpperLimit(new c.Pq(0,0,0)),t.setAngularLowerLimit(new c.Pq(Math.PI/4,0,0)),t.setAngularUpperLimit(new c.Pq(0,0,0));for(let e=0;e<6;++e)t.enableSpring(e,!0),t.setStiffness(e,100),t.setDamping(e,1);b.addConstraint(t,!1)}return t.onBeforeRenderObservable.add((()=>{b.stepSimulation(1/60,10,1/60),F.getTransformMatricesToArray(x),T.thinInstanceBufferUpdated("matrix")})),t}}}}]);