"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[9013],{2090:(e,n,t)=>{t.d(n,{D:()=>o});var i=t(5228),r=t(94444);class s{wait(){}}class o{wasmInstance;lock;constructor(e){this.wasmInstance=e,this.lock=new s}createRigidBodyImpl(){return new r.x}createRigidBodyBundleImpl(e){return new i.R(e.count)}}},80472:(e,n,t)=>{t.d(n,{y:()=>o});class i{_runtime;_ptr;_rigidBodyReferences;_rigidBodyBundleReferences;_constraintReferences;_referenceCount;constructor(e,n){this._runtime=e,this._ptr=n,this._rigidBodyReferences=new Set,this._rigidBodyBundleReferences=new Set,this._constraintReferences=new Set,this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose physics world while it still has references");if(0===this._ptr)return;const e=this._runtime.deref();void 0!==e&&(e.lock.wait(),e.wasmInstance.destroyPhysicsWorld(this._ptr)),this._ptr=0;for(const e of this._rigidBodyReferences)e.setWorldReference(null);this._rigidBodyReferences.clear();for(const e of this._rigidBodyBundleReferences)e.setWorldReference(null);this._rigidBodyBundleReferences.clear();for(const e of this._constraintReferences)e.setWorldReference(null);this._constraintReferences.clear()}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}addRigidBodyReference(e){return!this._rigidBodyReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyReferences.add(e),!0)}removeRigidBodyReference(e){return!!this._rigidBodyReferences.delete(e)&&(e.setWorldReference(null),!0)}addRigidBodyBundleReference(e){return!this._rigidBodyBundleReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyBundleReferences.add(e),!0)}removeRigidBodyBundleReference(e){return!!this._rigidBodyBundleReferences.delete(e)&&(e.setWorldReference(null),!0)}addConstraintReference(e){return!this._constraintReferences.has(e)&&(e.setWorldReference(this),this._constraintReferences.add(e),!0)}removeConstraintReference(e){return!!this._constraintReferences.delete(e)&&(e.setWorldReference(null),!0)}}function r(e){e.dispose()}const s=new WeakMap;class o{_runtime;_inner;constructor(e){this._runtime=e;const n=e.wasmInstance.createPhysicsWorld();this._inner=new i(new WeakRef(e),n);let t=s.get(e.wasmInstance);void 0===t&&(t=new FinalizationRegistry(r),s.set(e.wasmInstance,t)),t.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this._runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed physics world")}setGravity(e){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldSetGravity(this._inner.ptr,e.x,e.y,e.z)}stepSimulation(e,n,t){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldStepSimulation(this._inner.ptr,e,n,t)}addRigidBody(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body from different runtime");return this._nullCheck(),!!this._inner.addRigidBodyReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddRigidBody(this._inner.ptr,e.ptr),!0)}removeRigidBody(e){return this._nullCheck(),!!this._inner.removeRigidBodyReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveRigidBody(this._inner.ptr,e.ptr),!0)}addRigidBodyBundle(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body bundle from different runtime");return this._nullCheck(),!!this._inner.addRigidBodyBundleReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddRigidBodyBundle(this._inner.ptr,e.ptr),!0)}removeRigidBodyBundle(e){return this._nullCheck(),!!this._inner.removeRigidBodyBundleReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveRigidBodyBundle(this._inner.ptr,e.ptr),!0)}addConstraint(e,n){if(e.runtime!==this._runtime)throw new Error("Cannot add constraint from different runtime");return this._nullCheck(),!!this._inner.addConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldAddConstraint(this._inner.ptr,e.ptr,n),!0)}removeConstraint(e){return this._nullCheck(),!!this._inner.removeConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRemoveConstraint(this._inner.ptr,e.ptr),!0)}makeBodyKinematic(e){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldMakeBodyKinematic(this._inner.ptr,e.ptr)}restoreBodyDynamic(e){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.physicsWorldRestoreBodyDynamic(this._inner.ptr,e.ptr)}}},29013:(e,n,t)=>{t.r(n),t.d(n,{SceneBuilder:()=>C}),t(90203),t(33832),t(2093);var i=t(7839),r=t(52046),s=t(71513),o=t(18595),d=t(26041),a=t(79923),c=t(96793),h=t(58144),l=t(87491),u=t(46738),_=t(67168),f=t(2090),m=t(47002),w=t(26405),R=t(80472),y=t(1592),p=t(67648),B=t(35901),g=t(3477);class C{async build(e,n){const t=new l.Z(n);t.clearColor=new d.ov(.95,.95,.95,1);const C=new i.L("arcRotateCamera",0,0,500,new a.Pq(0,0,0),t);C.minZ=1,C.maxZ=1e3,C.setPosition(new a.Pq(60,40,-50)),C.attachControl(void 0,!1),C.inertia=.8,C.speed=10;const k=new s.g("hemisphericLight",new a.Pq(0,1,0),t);k.intensity=.5,k.specular=new d.v9(0,0,0),k.groundColor=new d.v9(1,1,1);const v=new r.Z("directionalLight",new a.Pq(.5,-1,1),t);v.intensity=.5;v.shadowMaxZ=60,v.shadowMinZ=-60,v.autoCalcShadowZBounds=!1,v.autoUpdateExtends=!1,v.shadowOrthoScale=0,v.orthoTop=60,v.orthoBottom=-60,v.orthoLeft=-60,v.orthoRight=60;const I=new o.o(2048,v,!0);I.transparencyShadow=!0,I.usePercentageCloserFiltering=!0,I.forceBackFacesOnly=!1,I.bias=.004,I.filteringQuality=o.o.QUALITY_MEDIUM;const W=await(0,u.e)(new m.t),S=new f.D(W),P=new R.y(S),b=new a.uq;{const e=(0,h.x)("ground",{size:120},t);e.rotationQuaternion=a.PT.RotationAxis(new a.Pq(1,0,0),Math.PI/2),I.addShadowCaster(e),e.receiveShadows=!0;const n=new w.Ty(S,new a.Pq(0,0,-1),0),i=new B.t(W);i.shape=n,a.uq.FromQuaternionToRef(e.rotationQuaternion,b),i.setInitialTransform(b),i.motionType=1;const r=new y.U(S,i);P.addRigidBody(r)}const q=1024,L=(0,c.an)("box",{size:2},t);I.addShadowCaster(L),L.receiveShadows=!0;const T=new Float32Array(16384);L.thinInstanceSetBuffer("matrix",T,16,!1);const x=new w.SA(S,new a.Pq(1,1,1)),A=new g.x(W,q);for(let e=0;e<q;++e){A.setShape(e,x);const n=a.uq.TranslationToRef(0,1+2*e,0,b);A.setInitialTransform(e,n),A.setFriction(e,1),A.setLinearDamping(e,.3),A.setAngularDamping(e,.3)}const M=new p.Y(S,A);P.addRigidBodyBundle(M);for(let e=0;e<q;e+=2){const n=[e,e+1],t=new _.vC(S,M,n,a.uq.Translation(0,-1.2,0),a.uq.Translation(0,1.2,0),!0);t.setLinearLowerLimit(new a.Pq(0,0,0)),t.setLinearUpperLimit(new a.Pq(0,0,0)),t.setAngularLowerLimit(new a.Pq(Math.PI/4,0,0)),t.setAngularUpperLimit(new a.Pq(0,0,0));for(let e=0;e<6;++e)t.enableSpring(e,!0),t.setStiffness(e,100),t.setDamping(e,1);P.addConstraint(t,!1)}return t.onBeforeRenderObservable.add((()=>{P.stepSimulation(1/60,10,1/60),M.getTransformMatricesToArray(T),L.thinInstanceBufferUpdated("matrix")})),t}}}}]);