"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[5499],{67648:(e,t,r)=>{r.d(t,{Y:()=>i});class n{_wasmInstance;_ptr;_shapeReferences;_referenceCount;_shadowCount;constructor(e,t,r){this._wasmInstance=e,this._ptr=t,this._shapeReferences=r;for(const e of r)e.addReference();this._referenceCount=0,this._shadowCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose rigid body bundle while it still has references");if(0!==this._ptr){this._wasmInstance.deref()?.destroyRigidBodyBundle(this._ptr),this._ptr=0;for(const e of this._shapeReferences)e.removeReference();this._shapeReferences.clear()}}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}addShadow(){this._shadowCount+=1}removeShadow(){this._shadowCount-=1}get hasShadows(){return 0<this._shadowCount}}function o(e){e.dispose()}const s=new WeakMap;class i{runtime;_motionStatesPtr;_bufferedMotionStatesPtr;_worldTransformPtrArray;_temporalKinematicStatesPtr;_inner;_count;_worldReference;impl;isContainsDynamic;constructor(e,t){if(0===t.ptr)throw new Error("Cannot create rigid body bundle with null pointer");const r=t.count,i=new Set;for(let n=0;n<r;++n){const r=t.getShape(n);if(null===r)throw new Error("Cannot create rigid body bundle with null shape");if(r.runtime!==e)throw new Error("Cannot create rigid body bundle with shapes from different runtimes");i.add(r)}this.runtime=e;const a=e.wasmInstance,h=a.createRigidBodyBundle(t.ptr,r),c=a.rigidBodyBundleGetMotionStatesPtr(h);this._motionStatesPtr=a.createTypedArray(Float32Array,c,20*r);const l=a.rigidBodyBundleGetBufferedMotionStatesPtr(h);this._bufferedMotionStatesPtr=a.createTypedArray(Float32Array,l,20*r);const d=[];let u=!1;for(let e=0;e<r;++e)if(0===t.getMotionType(e)){u=!0;const t=a.rigidBodyBundleGetWorldTransformPtr(h,e);d.push(a.createTypedArray(Float32Array,t,16))}else d.push(null);this._worldTransformPtrArray=d;const m=a.rigidBodyBundleGetTemporalKinematicStatesPtr(h);this._temporalKinematicStatesPtr=a.createTypedArray(Uint8Array,m,r),this._inner=new n(new WeakRef(e.wasmInstance),h,i),this._count=r,this._worldReference=null;let f=s.get(a);void 0===f&&(f=new FinalizationRegistry(o),s.set(a,f)),f.register(this,this._inner,this),this.impl=e.createRigidBodyBundleImpl(this),this.isContainsDynamic=u}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}get count(){return this._count}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}addShadowReference(){this._inner.addShadow()}removeShadowReference(){this._inner.removeShadow()}get hasShadows(){return this._inner.hasShadows}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add rigid body bundle to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}getWorldReference(){return this._worldReference}updateBufferedMotionStates(e){if(this._nullCheck(),e){const e=this.runtime.wasmInstance.rigidBodyBundleGetMotionStatesPtr(this._inner.ptr);this._bufferedMotionStatesPtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20*this._count)}else{const e=this.runtime.wasmInstance.rigidBodyBundleGetBufferedMotionStatesPtr(this._inner.ptr);this._bufferedMotionStatesPtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20*this._count)}}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed rigid body bundle")}getTransformMatrixToRef(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatesPtr.array,n=20*e;return t.set(r[n+4+0],r[n+8+0],r[n+12+0],0,r[n+4+1],r[n+8+1],r[n+12+1],0,r[n+4+2],r[n+8+2],r[n+12+2],0,r[n+16+0],r[n+16+1],r[n+16+2],1)}getTransformMatrixToArray(e,t,r=0){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const n=this._bufferedMotionStatesPtr.array,o=20*e;t[r+0]=n[o+4+0],t[r+1]=n[o+8+0],t[r+2]=n[o+12+0],t[r+3]=0,t[r+4]=n[o+4+1],t[r+5]=n[o+8+1],t[r+6]=n[o+12+1],t[r+7]=0,t[r+8]=n[o+4+2],t[r+9]=n[o+8+2],t[r+10]=n[o+12+2],t[r+11]=0,t[r+12]=n[o+16+0],t[r+13]=n[o+16+1],t[r+14]=n[o+16+2],t[r+15]=1}getTransformMatricesToArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatesPtr.array,n=this._count;let o=0,s=t;for(let t=0;t<n;++t)e[s+0]=r[o+4+0],e[s+1]=r[o+8+0],e[s+2]=r[o+12+0],e[s+3]=0,e[s+4]=r[o+4+1],e[s+5]=r[o+8+1],e[s+6]=r[o+12+1],e[s+7]=0,e[s+8]=r[o+4+2],e[s+9]=r[o+8+2],e[s+10]=r[o+12+2],e[s+11]=0,e[s+12]=r[o+16+0],e[s+13]=r[o+16+1],e[s+14]=r[o+16+2],e[s+15]=1,o+=20,s+=16}setTransformMatrix(e,t){this.setTransformMatrixFromArray(e,t.m,0)}setTransformMatrixFromArray(e,t,r=0){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatrixFromArray(this._motionStatesPtr,this._temporalKinematicStatesPtr,e,t,r)}setTransformMatricesFromArray(e,t=0){if(this._nullCheck(),e.length<16*this._count)throw new RangeError("Array is too short");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatricesFromArray(this._motionStatesPtr,this._temporalKinematicStatesPtr,e,t)}setDynamicTransformMatrix(e){this.setTransformMatricesFromArray(e.m,0)}setDynamicTransformMatrixFromArray(e,t,r=0){if(null===this._worldTransformPtrArray[e])throw new Error("Cannot set dynamic transform of non-dynamic body");if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setDynamicTransformMatrixFromArray(this._worldTransformPtrArray,e,t,r)}get needToCommit(){return this.impl.needToCommit??!1}commitToWasm(){if(void 0===this.impl.commitToWasm)throw new Error("commit only avalible on buffered evaluation mode");this._nullCheck(),this.runtime.lock.wait(),this.impl.commitToWasm(this.runtime.wasmInstance,this._inner.ptr,this._motionStatesPtr,this._temporalKinematicStatesPtr,this._worldTransformPtrArray)}}},45499:(e,t,r)=>{r.r(t),r.d(t,{SceneBuilder:()=>M}),r(90203),r(61440),r(33832),r(2093);var n=r(7839),o=r(52046),s=r(71513),i=r(18595),a=r(26041),h=r(79923),c=r(96793),l=r(58144),d=r(78121),u=r(87491),m=r(46738),f=r(67168),w=r(2090),p=r(27744),_=r(91167),y=r(15733),g=r(26405),T=r(1592),R=r(67648),S=r(35901),P=r(3477),b=r(89800),C=r(32399);class M{async build(e,t){const r=new u.Z(t);r.clearColor=new a.ov(.95,.95,.95,1);const M=new n.L("arcRotateCamera",0,0,500,new h.Pq(0,0,0),r);M.minZ=1,M.maxZ=3e3,M.setPosition(new h.Pq(60,40,-50).scaleInPlace(10)),M.attachControl(void 0,!1),M.inertia=.8,M.speed=10;const x=new s.g("hemisphericLight",new h.Pq(0,1,0),r);x.intensity=.5,x.specular=new a.v9(0,0,0),x.groundColor=new a.v9(1,1,1);const A=new o.Z("directionalLight",new h.Pq(.5,-1,1),r);A.intensity=.5;A.shadowMaxZ=250,A.shadowMinZ=-250,A.autoCalcShadowZBounds=!1,A.autoUpdateExtends=!1,A.shadowOrthoScale=0,A.orthoTop=250,A.orthoBottom=-250,A.orthoLeft=-250,A.orthoRight=250;const B=new i.o(2048,A,!0);B.transparencyShadow=!0,B.usePercentageCloserFiltering=!0,B.forceBackFacesOnly=!1,B.bias=.004,B.filteringQuality=i.o.QUALITY_MEDIUM;const I=parseInt(prompt("Thread count","2"));console.log("Thread count:",I);const k=1===I?await(0,m.e)(new _.Z):await(0,m.e)(new p.t,I),v=new w.D(k),F=new y.F(v,!0),q=new h.uq;{const e=(0,l.x)("ground",{size:500},r);e.rotationQuaternion=h.PT.RotationAxis(new h.Pq(1,0,0),Math.PI/2),B.addShadowCaster(e),e.receiveShadows=!0;const t=new g.Ty(v,new h.Pq(0,0,-1),0),n=new S.t(k);n.shape=t,h.uq.FromQuaternionToRef(e.rotationQuaternion,q),n.setInitialTransform(q),n.motionType=1;const o=new T.U(v,n);F.addRigidBodyToGlobal(o)}const E=512,L=[],D=[];if("u"===prompt("Shape type (u, r) uniform box, random","u")){const e=new h.Pq(1,1,1),t=new g.SA(v,e),r={type:"box",size:e};for(let e=0;e<E;++e)L.push(t),D.push(r)}else{const e=new C.q(0);for(let t=0;t<E;++t){const t=2*e.next()|0;if(0===t){const t=2*e.next()+.5,r=2*e.next()+.5,n=2*e.next()+.5,o=new h.Pq(t,r,n);L.push(new g.SA(v,o)),D.push({type:"box",size:o})}else{if(1!==t)throw new Error("Invalid type");{const t=2*e.next()+1;L.push(new g.O4(v,t)),D.push({type:"sphere",radius:t})}}}}const Q=[];for(let e=0;e<4;++e)for(let t=0;t<8;++t){const r=8*e+t,n=60*(t-4)+30,o=60*(e-2)+30,s=new P.x(k,E);for(let e=0;e<E;++e){s.setShape(e,L[e]);const t=h.uq.TranslationToRef(n,1+2*e,o,q);s.setInitialTransform(e,t),s.setFriction(e,1),s.setLinearDamping(e,.3),s.setAngularDamping(e,.3)}const i=new R.Y(v,s);F.addRigidBodyBundle(i,r);for(let e=0;e<E;e+=2){const t=[e,e+1],n=new f.vC(v,i,t,h.uq.Translation(0,-1.2,0),h.uq.Translation(0,1.2,0),!0);n.setLinearLowerLimit(new h.Pq(0,0,0)),n.setLinearUpperLimit(new h.Pq(0,0,0)),n.setAngularLowerLimit(new h.Pq(Math.PI/4,0,0)),n.setAngularUpperLimit(new h.Pq(0,0,0));for(let e=0;e<6;++e)n.enableSpring(e,!0),n.setStiffness(e,100),n.setDamping(e,1);F.addConstraint(n,r,!0)}Q.push(i)}console.log("Rigid body count:",16384);const W=[],Z=(0,c.an)("baseBox",{size:1},r),G=(0,d._6)("baseSphere",{diameter:1},r);Z.setEnabled(!1),G.setEnabled(!1),Z.receiveShadows=!0,G.receiveShadows=!0;for(let e=0;e<16384;++e){const t=D[e%D.length],r="box"===t.type?Z.createInstance(`boxInstance${e}`):G.createInstance(`sphereInstance${e}`);B.addShadowCaster(r),r.scaling.copyFrom("box"===t.type?t.size.scale(2):new h.Pq(t.radius,t.radius,t.radius).scale(2)),r.rotationQuaternion=h.PT.Identity(),W.push(r)}return new b.X((()=>{const e=performance.now();F.stepSimulation(1/60,10,1/60);for(let e=0;e<Q.length;++e){const t=Q[e];for(let r=0;r<E;++r){t.getTransformMatrixToRef(r,q);const n=W[e*E+r];q.getTranslationToRef(n.position),h.PT.FromRotationMatrixToRef(q,n.rotationQuaternion)}}const t=performance.now(),n=t-e;return r.render(),[n,performance.now()-t]})).runBench(),r.onBeforeRenderObservable.add((()=>{F.stepSimulation(1/60,10,1/60);for(let e=0;e<Q.length;++e){const t=Q[e];for(let r=0;r<E;++r){t.getTransformMatrixToRef(r,q);const n=W[e*E+r];q.getTranslationToRef(n.position),h.PT.FromRotationMatrixToRef(q,n.rotationQuaternion)}}})),r}}},32399:(e,t,r)=>{r.d(t,{q:()=>n});class n{_a;constructor(e){this._a=e}next(){let e=this._a+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296}}}}]);