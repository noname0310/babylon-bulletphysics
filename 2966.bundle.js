"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[2966],{2966:(e,n,t)=>{t.r(n),t.d(n,{SceneBuilder:()=>L}),t(203),t(1503),t(8227);var o=t(7456),a=t(5581),r=t(1513),s=t(9711),i=t(6041),c=t(9923),l=t(9899),w=t(8144),d=t(554),u=t(6738),h=t(7168),p=t(2090),f=t(7744),m=t(1167),g=t(5733),T=t(6405),y=t(1592),q=t(7648),P=t(5901),b=t(3477),S=t(9800);class L{async build(e,n){const t=new d.Z(n);t.clearColor=new i.ov(.95,.95,.95,1);const L=new o.Lq("arcRotateCamera",0,0,500,new c.Pq(0,0,0),t);L.minZ=1,L.maxZ=3e3,L.setPosition(new c.Pq(60,40,-50).scaleInPlace(10)),L.attachControl(void 0,!1),L.inertia=.8,L.speed=10;const B=new r.g("hemisphericLight",new c.Pq(0,1,0),t);B.intensity=.5,B.specular=new i.v9(0,0,0),B.groundColor=new i.v9(1,1,1);const C=new a.Z("directionalLight",new c.Pq(.5,-1,1),t);C.intensity=.5;C.shadowMaxZ=250,C.shadowMinZ=-250,C.autoCalcShadowZBounds=!1,C.autoUpdateExtends=!1,C.shadowOrthoScale=0,C.orthoTop=250,C.orthoBottom=-250,C.orthoLeft=-250,C.orthoRight=250;const x=new s.o(2048,C,!0);x.transparencyShadow=!0,x.usePercentageCloserFiltering=!0,x.forceBackFacesOnly=!1,x.bias=.004,x.filteringQuality=s.o.QUALITY_MEDIUM;const I=parseInt(prompt("Thread count","2"));console.log("Thread count:",I);const R=1===I?await(0,u.e)(new m.Z):await(0,u.e)(new f.t,I),v=new p.D(R),A=new g.F(v,!0),M=new c.uq;{const e=(0,w.x)("ground",{size:500},t);e.rotationQuaternion=c.PT.RotationAxis(new c.Pq(1,0,0),Math.PI/2),x.addShadowCaster(e),e.receiveShadows=!0;const n=new T.Ty(v,new c.Pq(0,0,-1),0),o=new P.t(R);o.shape=n,c.uq.FromQuaternionToRef(e.rotationQuaternion,M),o.setInitialTransform(M),o.motionType=1;const a=new y.U(v,o);A.addRigidBodyToGlobal(a)}const U=512,Z=(0,l.an)("box",{size:2},t);x.addShadowCaster(Z),Z.receiveShadows=!0;const F=new Float32Array(262144);Z.thinInstanceSetBuffer("matrix",F,16,!1);const k=new T.SA(v,new c.Pq(1,1,1)),D=[];for(let e=0;e<4;++e)for(let n=0;n<8;++n){const t=8*e+n,o=60*(n-4)+30,a=60*(e-2)+30,r=new b.x(R,U);for(let e=0;e<U;++e){r.setShape(e,k);const n=c.uq.TranslationToRef(o,1+2*e,a,M);r.setInitialTransform(e,n),r.setFriction(e,1),r.setLinearDamping(e,.3),r.setAngularDamping(e,.3)}const s=new q.Y(v,r);A.addRigidBodyBundle(s,t);for(let e=0;e<U;e+=2){const n=[e,e+1],o=new h.vC(v,s,n,c.uq.Translation(0,-1.2,0),c.uq.Translation(0,1.2,0),!0);o.setLinearLowerLimit(new c.Pq(0,0,0)),o.setLinearUpperLimit(new c.Pq(0,0,0)),o.setAngularLowerLimit(new c.Pq(Math.PI/4,0,0)),o.setAngularUpperLimit(new c.Pq(0,0,0));for(let e=0;e<6;++e)o.enableSpring(e,!0),o.setStiffness(e,100),o.setDamping(e,1);A.addConstraint(o,t,!0)}D.push(s)}return console.log("Rigid body count:",16384),new S.X((()=>{const e=performance.now();A.stepSimulation(1/60,10,1/60);for(let e=0;e<D.length;++e){const n=D[e],t=e*U*16;for(let e=0;e<U;++e)n.getTransformMatrixToRef(e,M),M.copyToArray(F,16*e+t)}Z.thinInstanceBufferUpdated("matrix");const n=performance.now(),o=n-e;return t.render(),[o,performance.now()-n]})).runBench(),t.onBeforeRenderObservable.add((()=>{A.stepSimulation(1/60,10,1/60);for(let e=0;e<D.length;++e)D[e].getTransformMatricesToArray(F,e*U*16);Z.thinInstanceBufferUpdated("matrix")})),t}}}}]);