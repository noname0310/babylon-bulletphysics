"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[3948],{40912:(e,i,t)=>{t.d(i,{d:()=>r});class r{shouldSync;_isDirty;_motionStateMatricesBuffer;_isMotionStateMatricesBufferDirty;_motionStateMatrixDirtyFlags;_dynamicTransformMatricesBuffer;_isDynamicTransformMatricesBufferDirty;_dynamicTransformMatrixDirtyFlags;_count;constructor(e){this.shouldSync=!1,this._isDirty=!1,this._motionStateMatricesBuffer=new Float32Array(16*e),this._isMotionStateMatricesBufferDirty=!1,this._motionStateMatrixDirtyFlags=new Uint8Array(e),this._dynamicTransformMatricesBuffer=null,this._isDynamicTransformMatricesBufferDirty=!1,this._dynamicTransformMatrixDirtyFlags=null,this._count=e}get needToCommit(){return this._isDirty}commitToWasm(e,i,t){if(this._isDirty){if(this._isMotionStateMatricesBufferDirty){const t=this._motionStateMatricesBuffer,r=e.array,s=this._motionStateMatrixDirtyFlags,n=i.array,o=this._count;let d=0,a=0;for(let e=0;e<o;++e)0!==s[e]?(r[a+4+0]=t[d],r[a+8+0]=t[d+1],r[a+12+0]=t[d+2],r[a+4+1]=t[d+4],r[a+8+1]=t[d+5],r[a+12+1]=t[d+6],r[a+4+2]=t[d+8],r[a+8+2]=t[d+9],r[a+12+2]=t[d+10],r[a+16+0]=t[d+12],r[a+16+1]=t[d+13],r[a+16+2]=t[d+14],0!==n[e]&&(n[e]=2),s[e]=0,d+=16,a+=20):(d+=16,a+=20);this._isMotionStateMatricesBufferDirty=!1}if(this._isDynamicTransformMatricesBufferDirty){const e=this._dynamicTransformMatricesBuffer,i=t,r=this._dynamicTransformMatrixDirtyFlags,s=this._count;let n=0;for(let t=0;t<s;++t){if(0===r[t]){n+=16;continue}const s=i[t].array;s[0]=e[n],s[16]=e[n+1],s[32]=e[n+2],s[1]=e[n+4],s[17]=e[n+5],s[33]=e[n+6],s[2]=e[n+8],s[18]=e[n+9],s[34]=e[n+10],s[48]=e[n+12],s[49]=e[n+13],s[50]=e[n+14],r[t]=0,n+=16}this._isDynamicTransformMatricesBufferDirty=!1}this._isDirty=!1}}setTransformMatrixFromArray(e,i,t,r,s){const n=this._motionStateMatricesBuffer,o=this._motionStateMatrixDirtyFlags,d=16*t;n[d+0]=r[s],n[d+1]=r[s+1],n[d+2]=r[s+2],n[d+3]=0,n[d+4]=r[s+4],n[d+5]=r[s+5],n[d+6]=r[s+6],n[d+7]=0,n[d+8]=r[s+8],n[d+9]=r[s+9],n[d+10]=r[s+10],n[d+11]=0,n[d+12]=r[s+12],n[d+13]=r[s+13],n[d+14]=r[s+14],n[d+15]=1,o[t]=1,this._isMotionStateMatricesBufferDirty=!0,this._isDirty=!0}setTransformMatricesFromArray(e,i,t,r){this._motionStateMatricesBuffer.set(t,r),this._motionStateMatrixDirtyFlags.fill(1),this._isMotionStateMatricesBufferDirty=!0,this._isDirty=!0}setDynamicTransformMatrixFromArray(e,i,t,r){null===this._dynamicTransformMatricesBuffer&&(this._dynamicTransformMatricesBuffer=new Float32Array(this._motionStateMatricesBuffer.length)),null===this._dynamicTransformMatrixDirtyFlags&&(this._dynamicTransformMatrixDirtyFlags=new Uint8Array(this._motionStateMatrixDirtyFlags.length));const s=this._dynamicTransformMatricesBuffer,n=16*i;s[n+0]=t[r],s[n+1]=t[r+1],s[n+2]=t[r+2],s[n+3]=0,s[n+4]=t[r+4],s[n+5]=t[r+5],s[n+6]=t[r+6],s[n+7]=0,s[n+8]=t[r+8],s[n+9]=t[r+9],s[n+10]=t[r+10],s[n+11]=0,s[n+12]=t[r+12],s[n+13]=t[r+13],s[n+14]=t[r+14],s[n+15]=1,this._dynamicTransformMatrixDirtyFlags[i]=1,this._isDynamicTransformMatricesBufferDirty=!0,this._isDirty=!0}}},23880:(e,i,t)=>{t.d(i,{V:()=>r});class r{shouldSync;_isDirty;_motionStateMatrixBuffer;_isMotionStateMatrixBufferDirty;_dynamicTransformMatrixBuffer;_isDynamicTransformMatrixBufferDirty;constructor(){this.shouldSync=!1,this._isDirty=!1,this._motionStateMatrixBuffer=new Float32Array(16),this._isMotionStateMatrixBufferDirty=!1,this._dynamicTransformMatrixBuffer=null,this._isDynamicTransformMatrixBufferDirty=!1}get needToCommit(){return this._isDirty}commitToWasm(e,i,t){if(this._isDirty){if(this._isMotionStateMatrixBufferDirty){const t=this._motionStateMatrixBuffer,r=e.array;r[4]=t[0],r[8]=t[1],r[12]=t[2],r[5]=t[4],r[9]=t[5],r[13]=t[6],r[6]=t[8],r[10]=t[9],r[14]=t[10],r[16]=t[12],r[17]=t[13],r[18]=t[14];const s=i.array;0!==s[0]&&(s[0]=2),this._isMotionStateMatrixBufferDirty=!1}if(this._isDynamicTransformMatrixBufferDirty){const e=this._dynamicTransformMatrixBuffer,i=t.array;i[0]=e[0],i[16]=e[1],i[32]=e[2],i[1]=e[4],i[17]=e[5],i[33]=e[6],i[2]=e[8],i[18]=e[9],i[34]=e[10],i[48]=e[12],i[49]=e[13],i[50]=e[14],this._isDynamicTransformMatrixBufferDirty=!1}this._isDirty=!1}}setTransformMatrixFromArray(e,i,t,r){this._motionStateMatrixBuffer.set(t,r),this._isMotionStateMatrixBufferDirty=!0,this._isDirty=!0}setDynamicTransformMatrixFromArray(e,i,t){null===this._dynamicTransformMatrixBuffer&&(this._dynamicTransformMatrixBuffer=new Float32Array(16)),this._dynamicTransformMatrixBuffer.set(i,t),this._isDynamicTransformMatrixBufferDirty=!0,this._isDirty=!0}}},23948:(e,i,t)=>{t.d(i,{h:()=>m});var r=t(79923),s=t(99848),n=t(87491),o=t(30037),d=t(15733),a=t(40912),h=t(23880),l=t(5228),c=t(94444),f=t(29009);class u{_lock;_wasmInstance;_ptr;_worldReference;constructor(e,i,t,r){this._lock=e,this._wasmInstance=i,this._ptr=t,this._worldReference=r,r.addReference()}dispose(){0!==this._ptr&&(this._lock.wait(),this._wasmInstance.deref()?.destroyMultiPhysicsRuntime(this._ptr),this._ptr=0,this._worldReference.removeReference(),this._worldReference=null)}get ptr(){return this._ptr}}function _(e){e.dispose()}const y=new WeakMap;class m{onTickObservable;wasmInstance;lock;_inner;_physicsWorld;_scene;_afterAnimationsBinded;_evaluationType;_usingWasmBackBuffer;_rigidBodyUsingBackBuffer;_preserveBackBuffer;_dynamicShadowCount;useDeltaForWorldStep;timeStep;maxSubSteps;fixedTimeStep;_rigidBodyList;_rigidBodyBundleList;constructor(e,i={}){const{allowDynamicShadow:t=!1,preserveBackBuffer:r=!1}=i;this.onTickObservable=new s.cP,this.wasmInstance=e;const n=new d.F(this,t),a=e.createMultiPhysicsRuntime(n.ptr),h=e.multiPhysicsRuntimeGetLockStatePtr(a);this.lock=new o.o(e.createTypedArray(Uint8Array,h,1)),r&&e.multiPhysicsWorldUseMotionStateBuffer(n.ptr,!0),this._inner=new u(this.lock,new WeakRef(e),a,n),this._physicsWorld=n;let l=y.get(e);void 0===l&&(l=new FinalizationRegistry(_),y.set(e,l)),l.register(this,this._inner,this),this._scene=null,this._afterAnimationsBinded=null,this._evaluationType=f.q.Immediate,this._usingWasmBackBuffer=r,this._rigidBodyUsingBackBuffer=!1,this._preserveBackBuffer=r,this._dynamicShadowCount=0,this.useDeltaForWorldStep=!0,this.timeStep=1/60,this.maxSubSteps=10,this.fixedTimeStep=1/60,this._rigidBodyList=[],this._rigidBodyBundleList=[]}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=y.get(this.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed physics runtime")}createRigidBodyImpl(){return this._evaluationType===f.q.Immediate?new c.x:new h.V}createRigidBodyBundleImpl(e){return this._evaluationType===f.q.Immediate?new l.R(e.count):new a.d(e.count)}register(e){null===this._afterAnimationsBinded&&(this._nullCheck(),this._afterAnimationsBinded=()=>{this.afterAnimations(e.getEngine().getDeltaTime())},this._scene=e,e.onAfterAnimationsObservable.add(this._afterAnimationsBinded))}unregister(){null!==this._afterAnimationsBinded&&(this._scene.onAfterAnimationsObservable.removeCallback(this._afterAnimationsBinded),this._afterAnimationsBinded=null,this._scene=null)}afterAnimations(e){if(0!==this._inner.ptr){if(this.useDeltaForWorldStep){const i=this._scene;e=null!==i&&i.useConstantAnimationDeltaTime?16:Math.max(n.Z.MinDeltaTime,Math.min(e,n.Z.MaxDeltaTime)),e/=1e3}else e=this.timeStep;if(this._evaluationType===f.q.Buffered){if(void 0===this.wasmInstance.multiPhysicsRuntimeBufferedStepSimulation&&this._physicsWorld.stepSimulation(e,this.maxSubSteps,this.fixedTimeStep),this.lock.wait(),this._preserveBackBuffer||this._usingWasmBackBuffer||(this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!0),this._usingWasmBackBuffer=!0),!1===this._rigidBodyUsingBackBuffer){this._rigidBodyUsingBackBuffer=!0;const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].updateBufferedMotionState(!1);const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].updateBufferedMotionStates(!1)}{const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].commitToWasm();const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].commitToWasm()}this.wasmInstance.multiPhysicsRuntimeBufferedStepSimulation?.(this._inner.ptr,e,this.maxSubSteps,this.fixedTimeStep)}else{if(this._preserveBackBuffer&&this.lock.wait(),!this._preserveBackBuffer&&this._usingWasmBackBuffer&&0===this._dynamicShadowCount&&(this.lock.wait(),this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!1),this._usingWasmBackBuffer=!1),!0===this._rigidBodyUsingBackBuffer){this.lock.wait(),this._rigidBodyUsingBackBuffer=!1;const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].updateBufferedMotionState(!0);const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].updateBufferedMotionStates(!0)}this._physicsWorld.stepSimulation(e,this.maxSubSteps,this.fixedTimeStep)}this.onTickObservable.notifyObservers()}else this.unregister()}get evaluationType(){return this._evaluationType}set evaluationType(e){if(this._evaluationType!==e)if(f.q.Buffered,this._evaluationType=e,e===f.q.Buffered){const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].impl=new h.V;const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].impl=new a.d(i[e].count)}else{const e=this._rigidBodyList;for(let i=0;i<e.length;++i){const t=e[i];t.needToCommit&&(this.lock.wait(),t.commitToWasm()),t.impl=new c.x}const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e){const t=i[e];t.needToCommit&&(this.lock.wait(),t.commitToWasm()),t.impl=new l.R(i[e].count)}}}_gravity=new r.Pq(0,-10,0);getGravityToRef(e){e.copyFrom(this._gravity)}setGravity(e){this._nullCheck(),this._gravity.copyFrom(e),this._physicsWorld.setGravity(e)}addRigidBody(e,i){this._nullCheck();const t=this._physicsWorld.addRigidBody(e,i);return t&&(this._rigidBodyList.push(e),this._rigidBodyUsingBackBuffer&&e.updateBufferedMotionState(!1)),t}removeRigidBody(e,i){this._nullCheck();const t=this._physicsWorld.removeRigidBody(e,i);if(t){const i=this._rigidBodyList.indexOf(e);-1!==i&&this._rigidBodyList.splice(i,1),e.updateBufferedMotionState(!1)}return t}addRigidBodyBundle(e,i){this._nullCheck();const t=this._physicsWorld.addRigidBodyBundle(e,i);return t&&(this._rigidBodyBundleList.push(e),this._rigidBodyUsingBackBuffer&&e.updateBufferedMotionStates(!1)),t}removeRigidBodyBundle(e,i){this._nullCheck();const t=this._physicsWorld.removeRigidBodyBundle(e,i);if(t){const i=this._rigidBodyBundleList.indexOf(e);-1!==i&&this._rigidBodyBundleList.splice(i,1),e.updateBufferedMotionStates(!1)}return t}addRigidBodyToGlobal(e){this._nullCheck();const i=this._physicsWorld.addRigidBodyToGlobal(e);return i&&this._rigidBodyList.push(e),i}removeRigidBodyFromGlobal(e){this._nullCheck();const i=this._physicsWorld.removeRigidBodyFromGlobal(e);if(i){const i=this._rigidBodyList.indexOf(e);-1!==i&&this._rigidBodyList.splice(i,1)}return i}addRigidBodyBundleToGlobal(e){this._nullCheck();const i=this._physicsWorld.addRigidBodyBundleToGlobal(e);return i&&this._rigidBodyBundleList.push(e),i}removeRigidBodyBundleFromGlobal(e){this._nullCheck();const i=this._physicsWorld.removeRigidBodyBundleFromGlobal(e);if(i){const i=this._rigidBodyBundleList.indexOf(e);-1!==i&&this._rigidBodyBundleList.splice(i,1)}return i}addRigidBodyShadow(e,i){this._nullCheck();let t=!1;this._usingWasmBackBuffer||(this.lock.wait(),this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!0),this._usingWasmBackBuffer=!0,t=!0);const r=this._physicsWorld.addRigidBodyShadow(e,i);return r?(this._rigidBodyList.push(e),this._dynamicShadowCount+=1):0===this._dynamicShadowCount&&t&&(this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!1),this._usingWasmBackBuffer=!1),r}removeRigidBodyShadow(e,i){this._nullCheck();const t=this._physicsWorld.removeRigidBodyShadow(e,i);if(t){const i=this._rigidBodyList.indexOf(e);-1!==i&&this._rigidBodyList.splice(i,1),this._dynamicShadowCount-=1}let r=!1;if(!this._preserveBackBuffer&&0===this._dynamicShadowCount&&this._usingWasmBackBuffer&&this._evaluationType!==f.q.Buffered&&(this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!1),this._usingWasmBackBuffer=!1,r=!0),r&&this._rigidBodyUsingBackBuffer){this._rigidBodyUsingBackBuffer=!1;const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].updateBufferedMotionState(!0);const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].updateBufferedMotionStates(!0)}return t}addRigidBodyBundleShadow(e,i){this._nullCheck();let t=!1;this._usingWasmBackBuffer||(this.lock.wait(),this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!0),this._usingWasmBackBuffer=!0,t=!0);const r=this._physicsWorld.addRigidBodyBundleShadow(e,i);return r?(this._rigidBodyBundleList.push(e),this._dynamicShadowCount+=1):0===this._dynamicShadowCount&&t&&(this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!1),this._usingWasmBackBuffer=!1),r}removeRigidBodyBundleShadow(e,i){this._nullCheck();const t=this._physicsWorld.removeRigidBodyBundleShadow(e,i);if(t){const i=this._rigidBodyBundleList.indexOf(e);-1!==i&&this._rigidBodyBundleList.splice(i,1),this._dynamicShadowCount-=1}let r=!1;if(!this._preserveBackBuffer&&0===this._dynamicShadowCount&&this._usingWasmBackBuffer&&this._evaluationType!==f.q.Buffered&&(this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!1),this._usingWasmBackBuffer=!1,r=!0),r&&this._rigidBodyUsingBackBuffer){this._rigidBodyUsingBackBuffer=!1;const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].updateBufferedMotionState(!0);const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].updateBufferedMotionStates(!0)}return t}get rigidBodyList(){return this._rigidBodyList}addConstraint(e,i,t){return this._nullCheck(),this._physicsWorld.addConstraint(e,i,t)}removeConstraint(e,i){return this._nullCheck(),this._physicsWorld.removeConstraint(e,i)}}},29009:(e,i,t)=>{var r;t.d(i,{q:()=>r}),function(e){e[e.Immediate=0]="Immediate",e[e.Buffered=1]="Buffered"}(r||(r={}))},30037:(e,i,t)=>{t.d(i,{o:()=>r});class r{_lock;constructor(e){this._lock=e}wait(){const e=this._lock.array,i=performance.now();for(;0!==Atomics.load(e,0);)if(performance.now()-i>1e4)throw new Error("Spinlock timeout")}}},15733:(e,i,t)=>{t.d(i,{F:()=>o});class r{_runtime;_ptr;_rigidBodyReferences;_rigidBodyBundleReferences;_rigidBodyGlobalReferences;_rigidBodyBundleGlobalReferences;_rigidBodyShadowReferences;_rigidBodyBundleShadowReferences;_constraintReferences;_referenceCount;constructor(e,i){this._runtime=e,this._ptr=i,this._rigidBodyReferences=new Map,this._rigidBodyBundleReferences=new Map,this._rigidBodyGlobalReferences=new Set,this._rigidBodyBundleGlobalReferences=new Set,this._rigidBodyShadowReferences=new Map,this._rigidBodyBundleShadowReferences=new Map,this._constraintReferences=new Set,this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose physics world while it still has references");if(0===this._ptr)return;const e=this._runtime.deref();void 0!==e&&(e.lock.wait(),e.wasmInstance.destroyMultiPhysicsWorld(this._ptr)),this._ptr=0;for(const[e,i]of this._rigidBodyReferences)e.setWorldReference(null);this._rigidBodyReferences.clear();for(const[e,i]of this._rigidBodyBundleReferences)e.setWorldReference(null);this._rigidBodyBundleReferences.clear();for(const e of this._rigidBodyGlobalReferences)e.removeReference();this._rigidBodyGlobalReferences.clear();for(const e of this._rigidBodyBundleGlobalReferences)e.removeReference();this._rigidBodyBundleGlobalReferences.clear();for(const e of this._rigidBodyShadowReferences.values())for(const i of e)i.removeReference();this._rigidBodyShadowReferences.clear();for(const e of this._rigidBodyBundleShadowReferences.values())for(const i of e)i.removeReference();this._rigidBodyBundleShadowReferences.clear();for(const e of this._constraintReferences)e.setWorldReference(null);this._constraintReferences.clear()}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}addRigidBodyReference(e,i){if(this._rigidBodyGlobalReferences.has(e))throw new Error("Rigid body is already added to the world as a global reference");const t=this._rigidBodyShadowReferences.get(i);if(void 0!==t&&t.has(e))throw new Error("Rigid body is already added to the world as a shadow reference");return!this._rigidBodyReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyReferences.set(e,i),!0)}removeRigidBodyReference(e){return!!this._rigidBodyReferences.delete(e)&&(e.setWorldReference(null),!0)}addRigidBodyBundleReference(e,i){if(this._rigidBodyBundleGlobalReferences.has(e))throw new Error("Rigid body bundle is already added to the world as a global reference");const t=this._rigidBodyBundleShadowReferences.get(i);if(void 0!==t&&t.has(e))throw new Error("Rigid body bundle is already added to the world as a shadow reference");return!this._rigidBodyBundleReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyBundleReferences.set(e,i),!0)}removeRigidBodyBundleReference(e){return!!this._rigidBodyBundleReferences.delete(e)&&(e.setWorldReference(null),!0)}addRigidBodyGlobalReference(e){if(null!==e.getWorldReference())throw new Error("Rigid body is already added to the world as a strong reference");return!this._rigidBodyGlobalReferences.has(e)&&(e.addReference(),this._rigidBodyGlobalReferences.add(e),!0)}removeRigidBodyGlobalReference(e){return!!this._rigidBodyGlobalReferences.delete(e)&&(e.removeReference(),!0)}addRigidBodyBundleGlobalReference(e){if(null!==e.getWorldReference())throw new Error("Rigid body bundle is already added to the world as a strong reference");return!this._rigidBodyBundleGlobalReferences.has(e)&&(e.addReference(),this._rigidBodyBundleGlobalReferences.add(e),!0)}removeRigidBodyBundleGlobalReference(e){return!!this._rigidBodyBundleGlobalReferences.delete(e)&&(e.removeReference(),!0)}addRigidBodyShadowReference(e,i){const t=this._rigidBodyReferences.get(e);if(void 0!==t&&t===i)return!1;if(this._rigidBodyGlobalReferences.has(e))throw new Error("Rigid body is already added to the world as a global reference");let r=this._rigidBodyShadowReferences.get(i);return void 0===r&&(r=new Set,this._rigidBodyShadowReferences.set(i,r)),!r.has(e)&&(e.addReference(),r.add(e),!0)}removeRigidBodyShadowReference(e,i){const t=this._rigidBodyShadowReferences.get(i);return!(void 0===t||!t.delete(e)||(0===t.size&&this._rigidBodyShadowReferences.delete(i),e.removeReference(),0))}addRigidBodyBundleShadowReference(e,i){const t=this._rigidBodyBundleReferences.get(e);if(void 0!==t&&t===i)return!1;if(this._rigidBodyBundleGlobalReferences.has(e))throw new Error("Rigid body bundle is already added to the world as a global reference");let r=this._rigidBodyBundleShadowReferences.get(i);return void 0===r&&(r=new Set,this._rigidBodyBundleShadowReferences.set(i,r)),!r.has(e)&&(e.addReference(),r.add(e),!0)}removeRigidBodyBundleShadowReference(e,i){const t=this._rigidBodyBundleShadowReferences.get(i);return!(void 0===t||!t.delete(e)||(0===t.size&&this._rigidBodyBundleShadowReferences.delete(i),e.removeReference(),0))}addConstraintReference(e){return!this._constraintReferences.has(e)&&(e.setWorldReference(this),this._constraintReferences.add(e),!0)}removeConstraintReference(e){return!!this._constraintReferences.delete(e)&&(e.setWorldReference(null),!0)}}function s(e){e.dispose()}const n=new WeakMap;class o{_runtime;_inner;constructor(e,i){this._runtime=e;const t=e.wasmInstance.createMultiPhysicsWorld(i);this._inner=new r(new WeakRef(e),t);let o=n.get(e.wasmInstance);void 0===o&&(o=new FinalizationRegistry(s),n.set(e.wasmInstance,o)),o.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=n.get(this._runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed physics world")}setGravity(e){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldSetGravity(this._inner.ptr,e.x,e.y,e.z)}stepSimulation(e,i,t){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldStepSimulation(this._inner.ptr,e,i,t)}addRigidBody(e,i){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body from a different runtime");return this._nullCheck(),!!this._inner.addRigidBodyReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBody(this._inner.ptr,i,e.ptr),!0)}removeRigidBody(e,i){if(e.hasShadows)throw new Error("Cannot remove rigid body that has shadows");return this._nullCheck(),!!this._inner.removeRigidBodyReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBody(this._inner.ptr,i,e.ptr),!0)}addRigidBodyBundle(e,i){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body bundle from a different runtime");return this._nullCheck(),!!this._inner.addRigidBodyBundleReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBodyBundle(this._inner.ptr,i,e.ptr),!0)}removeRigidBodyBundle(e,i){if(e.hasShadows)throw new Error("Cannot remove rigid body bundle that has shadows");return this._nullCheck(),!!this._inner.removeRigidBodyBundleReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBodyBundle(this._inner.ptr,i,e.ptr),!0)}addRigidBodyToGlobal(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body from a different runtime");if(e.isDynamic)throw new Error("Cannot add dynamic rigid body to global");return this._nullCheck(),!!this._inner.addRigidBodyGlobalReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBodyToGlobal(this._inner.ptr,e.ptr),!0)}removeRigidBodyFromGlobal(e){return this._nullCheck(),!!this._inner.removeRigidBodyGlobalReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBodyFromGlobal(this._inner.ptr,e.ptr),!0)}addRigidBodyBundleToGlobal(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body bundle from a different runtime");if(e.isContainsDynamic)throw new Error("Cannot add dynamic rigid body bundle to global");return this._nullCheck(),!!this._inner.addRigidBodyBundleGlobalReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBodyBundleToGlobal(this._inner.ptr,e.ptr),!0)}removeRigidBodyBundleFromGlobal(e){return this._nullCheck(),!!this._inner.removeRigidBodyBundleGlobalReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBodyBundleFromGlobal(this._inner.ptr,e.ptr),!0)}addRigidBodyShadow(e,i){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body from a different runtime");if(e.isDynamic&&null===e.getWorldReference())throw new Error("You must add dynamic rigid body first to the world before adding it as a shadow");return this._nullCheck(),!!this._inner.addRigidBodyShadowReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBodyShadow(this._inner.ptr,i,e.ptr),e.addShadowReference(),!0)}removeRigidBodyShadow(e,i){return this._nullCheck(),!!this._inner.removeRigidBodyShadowReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBodyShadow(this._inner.ptr,i,e.ptr),e.removeShadowReference(),!0)}addRigidBodyBundleShadow(e,i){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body bundle from a different runtime");if(e.isContainsDynamic&&null===e.getWorldReference())throw new Error("You must add dynamic rigid body bundle first to the world before adding it as a shadow");return this._nullCheck(),!!this._inner.addRigidBodyBundleShadowReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBodyBundleShadow(this._inner.ptr,i,e.ptr),e.addShadowReference(),!0)}removeRigidBodyBundleShadow(e,i){return this._nullCheck(),!!this._inner.removeRigidBodyBundleShadowReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBodyBundleShadow(this._inner.ptr,i,e.ptr),e.removeShadowReference(),!0)}addConstraint(e,i,t){if(e.runtime!==this._runtime)throw new Error("Cannot add constraint from a different runtime");return this._nullCheck(),!!this._inner.addConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddConstraint(this._inner.ptr,i,e.ptr,t),!0)}removeConstraint(e,i){return this._nullCheck(),!!this._inner.removeConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveConstraint(this._inner.ptr,i,e.ptr),!0)}}}}]);