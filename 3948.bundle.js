"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[3948],{40912:(e,i,t)=>{t.d(i,{d:()=>r});class r{shouldSync;_writeMatrices;_isWriteMatricesDirty;_writeMatrixDirtyFlags;_count;constructor(e){this.shouldSync=!1,this._writeMatrices=new Float32Array(16*e),this._isWriteMatricesDirty=!1,this._writeMatrixDirtyFlags=new Uint8Array(e),this._count=e}commitToMotionState(e){if(!this._isWriteMatricesDirty)return;const i=this._writeMatrices,t=e.array,r=this._writeMatrixDirtyFlags,s=this._count;let n=0,d=0;for(let e=0;e<s;++e)0!==r[e]?(t[d+4+0]=i[n],t[d+8+0]=i[n+1],t[d+12+0]=i[n+2],t[d+4+1]=i[n+4],t[d+8+1]=i[n+5],t[d+12+1]=i[n+6],t[d+4+2]=i[n+8],t[d+8+2]=i[n+9],t[d+12+2]=i[n+10],t[d+16+0]=i[n+12],t[d+16+1]=i[n+13],t[d+16+2]=i[n+14],r[e]=0,n+=16,d+=20):(n+=16,d+=20);this._isWriteMatricesDirty=!1}setTransformMatrixFromArray(e,i,t,r=0){const s=this._writeMatrices,n=this._writeMatrixDirtyFlags,d=16*i;s[d+0]=t[r],s[d+1]=t[r+1],s[d+2]=t[r+2],s[d+3]=0,s[d+4]=t[r+4],s[d+5]=t[r+5],s[d+6]=t[r+6],s[d+7]=0,s[d+8]=t[r+8],s[d+9]=t[r+9],s[d+10]=t[r+10],s[d+11]=0,s[d+12]=t[r+12],s[d+13]=t[r+13],s[d+14]=t[r+14],s[d+15]=1,n[i]=1,this._isWriteMatricesDirty=!0}setTransformMatricesFromArray(e,i,t=0){this._writeMatrices.set(i,t),this._isWriteMatricesDirty=!0}}},23880:(e,i,t)=>{t.d(i,{V:()=>r});class r{shouldSync;_writeMatrix;_isWriteMatrixDirty;constructor(){this.shouldSync=!1,this._writeMatrix=new Float32Array(16),this._isWriteMatrixDirty=!1}commitToMotionState(e){if(!this._isWriteMatrixDirty)return;const i=this._writeMatrix,t=e.array;t[4]=i[0],t[8]=i[1],t[12]=i[2],t[5]=i[4],t[9]=i[5],t[13]=i[6],t[6]=i[8],t[10]=i[9],t[14]=i[10],t[16]=i[12],t[17]=i[13],t[18]=i[14],this._isWriteMatrixDirty=!1}setTransformMatrixFromArray(e,i,t=0){this._writeMatrix.set(i,t),this._isWriteMatrixDirty=!0}}},23948:(e,i,t)=>{t.d(i,{h:()=>y});var r=t(79923),s=t(99848),n=t(87491),d=t(30037),o=t(15733),a=t(40912),h=t(23880),l=t(5228),c=t(94444),u=t(29009);class f{_lock;_wasmInstance;_ptr;_worldReference;constructor(e,i,t,r){this._lock=e,this._wasmInstance=i,this._ptr=t,this._worldReference=r,r.addReference()}dispose(){0!==this._ptr&&(this._lock.wait(),this._wasmInstance.deref()?.destroyMultiPhysicsRuntime(this._ptr),this._ptr=0,this._worldReference.removeReference(),this._worldReference=null)}get ptr(){return this._ptr}}function _(e){e.dispose()}const B=new WeakMap;class y{onTickObservable;wasmInstance;lock;_inner;_physicsWorld;_scene;_afterAnimationsBinded;_evaluationType;_usingWasmBackBuffer;_rigidBodyUsingBackBuffer;_preserveBackBuffer;_dynamicShadowCount;useDeltaForWorldStep;timeStep;maxSubSteps;fixedTimeStep;_rigidBodyList;_rigidBodyBundleList;constructor(e,i={}){const{allowDynamicShadow:t=!1,preserveBackBuffer:r=!1}=i;this.onTickObservable=new s.cP,this.wasmInstance=e;const n=new o.F(this,t),a=e.createMultiPhysicsRuntime(n.ptr),h=e.multiPhysicsRuntimeGetLockStatePtr(a);this.lock=new d.o(e.createTypedArray(Uint8Array,h,1)),r&&e.multiPhysicsWorldUseMotionStateBuffer(n.ptr,!0),this._inner=new f(this.lock,new WeakRef(e),a,n),this._physicsWorld=n;let l=B.get(e);void 0===l&&(l=new FinalizationRegistry(_),B.set(e,l)),l.register(this,this._inner,this),this._scene=null,this._afterAnimationsBinded=null,this._evaluationType=u.q.Immediate,this._usingWasmBackBuffer=r,this._rigidBodyUsingBackBuffer=!1,this._preserveBackBuffer=r,this._dynamicShadowCount=0,this.useDeltaForWorldStep=!0,this.timeStep=1/60,this.maxSubSteps=10,this.fixedTimeStep=1/60,this._rigidBodyList=[],this._rigidBodyBundleList=[]}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=B.get(this.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed physics runtime")}createRigidBodyImpl(){return this._evaluationType===u.q.Immediate?new c.x:new h.V}createRigidBodyBundleImpl(e){return this._evaluationType===u.q.Immediate?new l.R(e.count):new a.d(e.count)}register(e){null===this._afterAnimationsBinded&&(this._nullCheck(),this._afterAnimationsBinded=()=>{this.afterAnimations(e.getEngine().getDeltaTime())},this._scene=e,e.onAfterAnimationsObservable.add(this._afterAnimationsBinded))}unregister(){null!==this._afterAnimationsBinded&&(this._scene.onAfterAnimationsObservable.removeCallback(this._afterAnimationsBinded),this._afterAnimationsBinded=null,this._scene=null)}afterAnimations(e){if(0!==this._inner.ptr){if(this.useDeltaForWorldStep){const i=this._scene;e=null!==i&&i.useConstantAnimationDeltaTime?16:Math.max(n.Z.MinDeltaTime,Math.min(e,n.Z.MaxDeltaTime)),e/=1e3}else e=this.timeStep;if(this._evaluationType===u.q.Buffered){if(void 0===this.wasmInstance.multiPhysicsRuntimeBufferedStepSimulation&&this._physicsWorld.stepSimulation(e,this.maxSubSteps,this.fixedTimeStep),this.lock.wait(),this._preserveBackBuffer||this._usingWasmBackBuffer||(this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!0),this._usingWasmBackBuffer=!0),!1===this._rigidBodyUsingBackBuffer){this._rigidBodyUsingBackBuffer=!0;const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].updateBufferedMotionState(!1);const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].updateBufferedMotionStates(!1)}this.wasmInstance.multiPhysicsRuntimeBufferedStepSimulation?.(this._inner.ptr,e,this.maxSubSteps,this.fixedTimeStep)}else{if(this._preserveBackBuffer&&this.lock.wait(),!this._preserveBackBuffer&&this._usingWasmBackBuffer&&0===this._dynamicShadowCount&&(this.lock.wait(),this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!1),this._usingWasmBackBuffer=!1),!0===this._rigidBodyUsingBackBuffer){this.lock.wait(),this._rigidBodyUsingBackBuffer=!1;const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].updateBufferedMotionState(!0);const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].updateBufferedMotionStates(!0)}this._physicsWorld.stepSimulation(e,this.maxSubSteps,this.fixedTimeStep)}this.onTickObservable.notifyObservers()}else this.unregister()}get evaluationType(){return this._evaluationType}set evaluationType(e){if(this._evaluationType!==e)if(u.q.Buffered,this._evaluationType=e,e===u.q.Buffered){const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].impl=new h.V;const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].impl=new a.d(i[e].count)}else{const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].impl=new c.x;const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].impl=new l.R(i[e].count)}}_gravity=new r.Pq(0,-10,0);getGravityToRef(e){e.copyFrom(this._gravity)}setGravity(e){this._nullCheck(),this._gravity.copyFrom(e),this._physicsWorld.setGravity(e)}addRigidBody(e,i){this._nullCheck();const t=this._physicsWorld.addRigidBody(e,i);return t&&(this._rigidBodyList.push(e),this._rigidBodyUsingBackBuffer&&e.updateBufferedMotionState(!1)),t}removeRigidBody(e,i){this._nullCheck();const t=this._physicsWorld.removeRigidBody(e,i);if(t){const i=this._rigidBodyList.indexOf(e);-1!==i&&this._rigidBodyList.splice(i,1),e.updateBufferedMotionState(!1)}return t}addRigidBodyBundle(e,i){this._nullCheck();const t=this._physicsWorld.addRigidBodyBundle(e,i);return t&&(this._rigidBodyBundleList.push(e),this._rigidBodyUsingBackBuffer&&e.updateBufferedMotionStates(!1)),t}removeRigidBodyBundle(e,i){this._nullCheck();const t=this._physicsWorld.removeRigidBodyBundle(e,i);if(t){const i=this._rigidBodyBundleList.indexOf(e);-1!==i&&this._rigidBodyBundleList.splice(i,1),e.updateBufferedMotionStates(!1)}return t}addRigidBodyToGlobal(e){this._nullCheck();const i=this._physicsWorld.addRigidBodyToGlobal(e);return i&&this._rigidBodyList.push(e),i}removeRigidBodyFromGlobal(e){this._nullCheck();const i=this._physicsWorld.removeRigidBodyFromGlobal(e);if(i){const i=this._rigidBodyList.indexOf(e);-1!==i&&this._rigidBodyList.splice(i,1)}return i}addRigidBodyBundleToGlobal(e){this._nullCheck();const i=this._physicsWorld.addRigidBodyBundleToGlobal(e);return i&&this._rigidBodyBundleList.push(e),i}removeRigidBodyBundleFromGlobal(e){this._nullCheck();const i=this._physicsWorld.removeRigidBodyBundleFromGlobal(e);if(i){const i=this._rigidBodyBundleList.indexOf(e);-1!==i&&this._rigidBodyBundleList.splice(i,1)}return i}addRigidBodyShadow(e,i){this._nullCheck();let t=!1;this._usingWasmBackBuffer||(this.lock.wait(),this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!0),this._usingWasmBackBuffer=!0,t=!0);const r=this._physicsWorld.addRigidBodyShadow(e,i);return r?(this._rigidBodyList.push(e),this._dynamicShadowCount+=1):0===this._dynamicShadowCount&&t&&(this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!1),this._usingWasmBackBuffer=!1),r}removeRigidBodyShadow(e,i){this._nullCheck();const t=this._physicsWorld.removeRigidBodyShadow(e,i);if(t){const i=this._rigidBodyList.indexOf(e);-1!==i&&this._rigidBodyList.splice(i,1),this._dynamicShadowCount-=1}let r=!1;if(!this._preserveBackBuffer&&0===this._dynamicShadowCount&&this._usingWasmBackBuffer&&this._evaluationType!==u.q.Buffered&&(this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!1),this._usingWasmBackBuffer=!1,r=!0),r&&this._rigidBodyUsingBackBuffer){this._rigidBodyUsingBackBuffer=!1;const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].updateBufferedMotionState(!0);const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].updateBufferedMotionStates(!0)}return t}addRigidBodyBundleShadow(e,i){this._nullCheck();let t=!1;this._usingWasmBackBuffer||(this.lock.wait(),this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!0),this._usingWasmBackBuffer=!0,t=!0);const r=this._physicsWorld.addRigidBodyBundleShadow(e,i);return r?(this._rigidBodyBundleList.push(e),this._dynamicShadowCount+=1):0===this._dynamicShadowCount&&t&&(this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!1),this._usingWasmBackBuffer=!1),r}removeRigidBodyBundleShadow(e,i){this._nullCheck();const t=this._physicsWorld.removeRigidBodyBundleShadow(e,i);if(t){const i=this._rigidBodyBundleList.indexOf(e);-1!==i&&this._rigidBodyBundleList.splice(i,1),this._dynamicShadowCount-=1}let r=!1;if(!this._preserveBackBuffer&&0===this._dynamicShadowCount&&this._usingWasmBackBuffer&&this._evaluationType!==u.q.Buffered&&(this.wasmInstance.multiPhysicsWorldUseMotionStateBuffer(this._physicsWorld.ptr,!1),this._usingWasmBackBuffer=!1,r=!0),r&&this._rigidBodyUsingBackBuffer){this._rigidBodyUsingBackBuffer=!1;const e=this._rigidBodyList;for(let i=0;i<e.length;++i)e[i].updateBufferedMotionState(!0);const i=this._rigidBodyBundleList;for(let e=0;e<i.length;++e)i[e].updateBufferedMotionStates(!0)}return t}get rigidBodyList(){return this._rigidBodyList}addConstraint(e,i,t){return this._nullCheck(),this._physicsWorld.addConstraint(e,i,t)}removeConstraint(e,i){return this._nullCheck(),this._physicsWorld.removeConstraint(e,i)}}},29009:(e,i,t)=>{var r;t.d(i,{q:()=>r}),function(e){e[e.Immediate=0]="Immediate",e[e.Buffered=1]="Buffered"}(r||(r={}))},30037:(e,i,t)=>{t.d(i,{o:()=>r});class r{_lock;constructor(e){this._lock=e}wait(){const e=this._lock.array,i=performance.now();for(;0!==Atomics.load(e,0);)if(performance.now()-i>1e4)throw new Error("Spinlock timeout")}}},15733:(e,i,t)=>{t.d(i,{F:()=>d});class r{worldKind;_runtime;_ptr;_rigidBodyReferences;_rigidBodyBundleReferences;_rigidBodyGlobalReferences;_rigidBodyBundleGlobalReferences;_rigidBodyShadowReferences;_rigidBodyBundleShadowReferences;_constraintReferences;_referenceCount;constructor(e,i){this.worldKind=1,this._runtime=e,this._ptr=i,this._rigidBodyReferences=new Map,this._rigidBodyBundleReferences=new Map,this._rigidBodyGlobalReferences=new Set,this._rigidBodyBundleGlobalReferences=new Set,this._rigidBodyShadowReferences=new Map,this._rigidBodyBundleShadowReferences=new Map,this._constraintReferences=new Set,this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose physics world while it still has references");if(0===this._ptr)return;const e=this._runtime.deref();void 0!==e&&(e.lock.wait(),e.wasmInstance.destroyMultiPhysicsWorld(this._ptr)),this._ptr=0;for(const[e,i]of this._rigidBodyReferences)e.setWorldReference(null);this._rigidBodyReferences.clear();for(const[e,i]of this._rigidBodyBundleReferences)e.setWorldReference(null);this._rigidBodyBundleReferences.clear();for(const e of this._rigidBodyGlobalReferences)e.removeReference();this._rigidBodyGlobalReferences.clear();for(const e of this._rigidBodyBundleGlobalReferences)e.removeReference();this._rigidBodyBundleGlobalReferences.clear();for(const e of this._rigidBodyShadowReferences.values())for(const i of e)i.removeReference();this._rigidBodyShadowReferences.clear();for(const e of this._rigidBodyBundleShadowReferences.values())for(const i of e)i.removeReference();this._rigidBodyBundleShadowReferences.clear();for(const e of this._constraintReferences)e.setWorldReference(null);this._constraintReferences.clear()}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}addRigidBodyReference(e,i){if(this._rigidBodyGlobalReferences.has(e))throw new Error("Rigid body is already added to the world as a global reference");const t=this._rigidBodyShadowReferences.get(i);if(void 0!==t&&t.has(e))throw new Error("Rigid body is already added to the world as a shadow reference");return!this._rigidBodyReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyReferences.set(e,i),!0)}removeRigidBodyReference(e){return!!this._rigidBodyReferences.delete(e)&&(e.setWorldReference(null),!0)}addRigidBodyBundleReference(e,i){if(this._rigidBodyBundleGlobalReferences.has(e))throw new Error("Rigid body bundle is already added to the world as a global reference");const t=this._rigidBodyBundleShadowReferences.get(i);if(void 0!==t&&t.has(e))throw new Error("Rigid body bundle is already added to the world as a shadow reference");return!this._rigidBodyBundleReferences.has(e)&&(e.setWorldReference(this),this._rigidBodyBundleReferences.set(e,i),!0)}removeRigidBodyBundleReference(e){return!!this._rigidBodyBundleReferences.delete(e)&&(e.setWorldReference(null),!0)}addRigidBodyGlobalReference(e){if(null!==e.getWorldReference())throw new Error("Rigid body is already added to the world as a strong reference");return!this._rigidBodyGlobalReferences.has(e)&&(e.addReference(),this._rigidBodyGlobalReferences.add(e),!0)}removeRigidBodyGlobalReference(e){return!!this._rigidBodyGlobalReferences.delete(e)&&(e.removeReference(),!0)}addRigidBodyBundleGlobalReference(e){if(null!==e.getWorldReference())throw new Error("Rigid body bundle is already added to the world as a strong reference");return!this._rigidBodyBundleGlobalReferences.has(e)&&(e.addReference(),this._rigidBodyBundleGlobalReferences.add(e),!0)}removeRigidBodyBundleGlobalReference(e){return!!this._rigidBodyBundleGlobalReferences.delete(e)&&(e.removeReference(),!0)}addRigidBodyShadowReference(e,i){const t=this._rigidBodyReferences.get(e);if(void 0!==t&&t===i)return!1;if(this._rigidBodyGlobalReferences.has(e))throw new Error("Rigid body is already added to the world as a global reference");let r=this._rigidBodyShadowReferences.get(i);return void 0===r&&(r=new Set,this._rigidBodyShadowReferences.set(i,r)),!r.has(e)&&(e.addReference(),r.add(e),!0)}removeRigidBodyShadowReference(e,i){const t=this._rigidBodyShadowReferences.get(i);return!(void 0===t||!t.delete(e)||(0===t.size&&this._rigidBodyShadowReferences.delete(i),e.removeReference(),0))}addRigidBodyBundleShadowReference(e,i){const t=this._rigidBodyBundleReferences.get(e);if(void 0!==t&&t===i)return!1;if(this._rigidBodyBundleGlobalReferences.has(e))throw new Error("Rigid body bundle is already added to the world as a global reference");let r=this._rigidBodyBundleShadowReferences.get(i);return void 0===r&&(r=new Set,this._rigidBodyBundleShadowReferences.set(i,r)),!r.has(e)&&(e.addReference(),r.add(e),!0)}removeRigidBodyBundleShadowReference(e,i){const t=this._rigidBodyBundleShadowReferences.get(i);return!(void 0===t||!t.delete(e)||(0===t.size&&this._rigidBodyBundleShadowReferences.delete(i),e.removeReference(),0))}addConstraintReference(e){return!this._constraintReferences.has(e)&&(e.setWorldReference(this),this._constraintReferences.add(e),!0)}removeConstraintReference(e){return!!this._constraintReferences.delete(e)&&(e.setWorldReference(null),!0)}}function s(e){e.dispose()}const n=new WeakMap;class d{_runtime;_inner;constructor(e,i){this._runtime=e;const t=e.wasmInstance.createMultiPhysicsWorld(i);this._inner=new r(new WeakRef(e),t);let d=n.get(e.wasmInstance);void 0===d&&(d=new FinalizationRegistry(s),n.set(e.wasmInstance,d)),d.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=n.get(this._runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed physics world")}setGravity(e){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldSetGravity(this._inner.ptr,e.x,e.y,e.z)}stepSimulation(e,i,t){this._nullCheck(),this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldStepSimulation(this._inner.ptr,e,i,t)}addRigidBody(e,i){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body from a different runtime");return this._nullCheck(),!!this._inner.addRigidBodyReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBody(this._inner.ptr,i,e.ptr),!0)}removeRigidBody(e,i){if(e.hasShadows)throw new Error("Cannot remove rigid body that has shadows");return this._nullCheck(),!!this._inner.removeRigidBodyReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBody(this._inner.ptr,i,e.ptr),!0)}addRigidBodyBundle(e,i){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body bundle from a different runtime");return this._nullCheck(),!!this._inner.addRigidBodyBundleReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBodyBundle(this._inner.ptr,i,e.ptr),!0)}removeRigidBodyBundle(e,i){if(e.hasShadows)throw new Error("Cannot remove rigid body bundle that has shadows");return this._nullCheck(),!!this._inner.removeRigidBodyBundleReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBodyBundle(this._inner.ptr,i,e.ptr),!0)}addRigidBodyToGlobal(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body from a different runtime");if(e.isDynamic)throw new Error("Cannot add dynamic rigid body to global");return this._nullCheck(),!!this._inner.addRigidBodyGlobalReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBodyToGlobal(this._inner.ptr,e.ptr),!0)}removeRigidBodyFromGlobal(e){return this._nullCheck(),!!this._inner.removeRigidBodyGlobalReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBodyFromGlobal(this._inner.ptr,e.ptr),!0)}addRigidBodyBundleToGlobal(e){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body bundle from a different runtime");if(e.isContainsDynamic)throw new Error("Cannot add dynamic rigid body bundle to global");return this._nullCheck(),!!this._inner.addRigidBodyBundleGlobalReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBodyBundleToGlobal(this._inner.ptr,e.ptr),!0)}removeRigidBodyBundleFromGlobal(e){return this._nullCheck(),!!this._inner.removeRigidBodyBundleGlobalReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBodyBundleFromGlobal(this._inner.ptr,e.ptr),!0)}addRigidBodyShadow(e,i){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body from a different runtime");if(e.isDynamic&&null===e.getWorldReference())throw new Error("You must add dynamic rigid body first to the world before adding it as a shadow");return this._nullCheck(),!!this._inner.addRigidBodyShadowReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBodyShadow(this._inner.ptr,i,e.ptr),e.addShadowReference(),!0)}removeRigidBodyShadow(e,i){return this._nullCheck(),!!this._inner.removeRigidBodyShadowReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBodyShadow(this._inner.ptr,i,e.ptr),e.removeShadowReference(),!0)}addRigidBodyBundleShadow(e,i){if(e.runtime!==this._runtime)throw new Error("Cannot add rigid body bundle from a different runtime");if(e.isContainsDynamic&&null===e.getWorldReference())throw new Error("You must add dynamic rigid body bundle first to the world before adding it as a shadow");return this._nullCheck(),!!this._inner.addRigidBodyBundleShadowReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddRigidBodyBundleShadow(this._inner.ptr,i,e.ptr),e.addShadowReference(),!0)}removeRigidBodyBundleShadow(e,i){return this._nullCheck(),!!this._inner.removeRigidBodyBundleShadowReference(e,i)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveRigidBodyBundleShadow(this._inner.ptr,i,e.ptr),e.removeShadowReference(),!0)}addConstraint(e,i,t){if(e.runtime!==this._runtime)throw new Error("Cannot add constraint from a different runtime");return this._nullCheck(),!!this._inner.addConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldAddConstraint(this._inner.ptr,i,e.ptr,t),!0)}removeConstraint(e,i){return this._nullCheck(),!!this._inner.removeConstraintReference(e)&&(this._runtime.lock.wait(),this._runtime.wasmInstance.multiPhysicsWorldRemoveConstraint(this._inner.ptr,i,e.ptr),!0)}}}}]);