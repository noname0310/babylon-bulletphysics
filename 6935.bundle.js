"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[6935],{1592:(e,t,r)=>{r.d(t,{U:()=>a});class n{_wasmInstance;_ptr;_vector3Buffer1;_vector3Buffer2;_shapeReference;_referenceCount;_shadowCount;constructor(e,t,r){this._wasmInstance=new WeakRef(e),this._ptr=t;const n=e.allocateBuffer(12);this._vector3Buffer1=e.createTypedArray(Float32Array,n,3);const i=e.allocateBuffer(12);this._vector3Buffer2=e.createTypedArray(Float32Array,i,3),this._shapeReference=r,r.addReference(),this._referenceCount=0,this._shadowCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose rigid body while it still has references");if(this._shadowCount>0)throw new Error("Cannot dispose rigid body while it still has shadows");if(0===this._ptr)return;const e=this._wasmInstance.deref();void 0!==e&&(e.deallocateBuffer(this._vector3Buffer1.array.byteOffset,12),e.deallocateBuffer(this._vector3Buffer2.array.byteOffset,12),e.destroyRigidBody(this._ptr)),this._ptr=0,this._shapeReference.removeReference(),this._shapeReference=null}get ptr(){return this._ptr}get vector3Buffer1(){return this._vector3Buffer1}get vector3Buffer2(){return this._vector3Buffer2}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}addShadow(){this._shadowCount+=1}removeShadow(){this._shadowCount-=1}get hasShadows(){return 0<this._shadowCount}getShapeReference(){return this._shapeReference}setShapeReference(e){this._shapeReference.removeReference(),this._shapeReference=e,e.addReference()}}function i(e){e.dispose()}const s=new WeakMap;class a{runtime;_motionStatePtr;_bufferedMotionStatePtr;_worldTransformPtr;_temporalKinematicStatePtr;_inner;_worldReference;impl;isDynamic;constructor(e,t,r){const a=void 0!==r?t.getPtr(r):t.ptr;if(0===a)throw new Error("Cannot create rigid body with null pointer");let h;if(h=void 0!==r?t.getShape(r):t.shape,null===h)throw new Error("Cannot create rigid body with null shape");if(h.runtime!==e)throw new Error("Cannot create rigid body with shapes from different runtimes");const o=void 0!==r?0===t.getMotionType(r):0===t.motionType;this.runtime=e;const c=e.wasmInstance,l=c.createRigidBody(a),u=c.rigidBodyGetMotionStatePtr(l);this._motionStatePtr=c.createTypedArray(Float32Array,u,20);const _=c.rigidBodyGetBufferedMotionStatePtr(l);if(this._bufferedMotionStatePtr=c.createTypedArray(Float32Array,_,20),o){const e=c.rigidBodyGetWorldTransformPtr(l);this._worldTransformPtr=c.createTypedArray(Float32Array,e,16)}else this._worldTransformPtr=null;const f=c.rigidBodyGetTemporalKinematicStatePtr(l);this._temporalKinematicStatePtr=c.createTypedArray(Uint8Array,f,1),this._inner=new n(e.wasmInstance,l,h),this._worldReference=null;let y=s.get(c);void 0===y&&(y=new FinalizationRegistry(i),s.set(c,y)),y.register(this,this._inner,this),this.impl=e.createRigidBodyImpl(),this.isDynamic=o}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}addShadowReference(){this._inner.addShadow()}removeShadowReference(){this._inner.removeShadow()}get hasShadows(){return this._inner.hasShadows}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add rigid body to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==this._worldReference?this._inner.addReference():this._inner.removeReference())}getWorldReference(){return this._worldReference}updateBufferedMotionState(e){if(this._nullCheck(),e){const e=this.runtime.wasmInstance.rigidBodyGetMotionStatePtr(this._inner.ptr);this._bufferedMotionStatePtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20)}else{const e=this.runtime.wasmInstance.rigidBodyGetBufferedMotionStatePtr(this._inner.ptr);this._bufferedMotionStatePtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20)}}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed rigid body")}getTransformMatrixToRef(e){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const t=this._bufferedMotionStatePtr.array;return e.set(t[4],t[8],t[12],0,t[5],t[9],t[13],0,t[6],t[10],t[14],0,t[16],t[17],t[18],1)}getTransformMatrixToArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatePtr.array;e[t+0]=r[4],e[t+1]=r[8],e[t+2]=r[12],e[t+3]=0,e[t+4]=r[5],e[t+5]=r[9],e[t+6]=r[13],e[t+7]=0,e[t+8]=r[6],e[t+9]=r[10],e[t+10]=r[14],e[t+11]=0,e[t+12]=r[16],e[t+13]=r[17],e[t+14]=r[18],e[t+15]=1}setTransformMatrix(e){this.setTransformMatrixFromArray(e.m,0)}setTransformMatrixFromArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatrixFromArray(this._motionStatePtr,this._temporalKinematicStatePtr,e,t)}setDynamicTransformMatrix(e,t=!1){this.setDynamicTransformMatrixFromArray(e.m,0,t)}setDynamicTransformMatrixFromArray(e,t=0,r=!1){if(null===this._worldTransformPtr){if(r)return void this.setTransformMatrixFromArray(e,t);throw new Error("Cannot set dynamic transform of non-dynamic body")}this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setDynamicTransformMatrixFromArray(this._worldTransformPtr,e,t)}setDamping(e,t){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setDamping(this.runtime.wasmInstance,this._inner.ptr,e,t)}getLinearDamping(){return this._nullCheck(),this.impl.getLinearDamping(this.runtime.wasmInstance,this._inner.ptr)}getAngularDamping(){return this._nullCheck(),this.impl.getAngularDamping(this.runtime.wasmInstance,this._inner.ptr)}setMassProps(e,t){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setMassProps(this.runtime.wasmInstance,this._inner.ptr,e,t)}getMass(){return this._nullCheck(),this.impl.getMass(this.runtime.wasmInstance,this._inner.ptr)}getLocalInertia(){return this._nullCheck(),this.impl.getLocalInertia(this.runtime.wasmInstance,this._inner.ptr)}translate(e){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.translate(this.runtime.wasmInstance,this._inner.ptr,e)}get needToCommit(){return this.impl.needToCommit??!1}commitToWasm(){if(void 0===this.impl.commitToWasm)throw new Error("commit only avalible on buffered evaluation mode");this._nullCheck(),this.runtime.lock.wait(),this.impl.commitToWasm(this.runtime.wasmInstance,this._inner.ptr,this._motionStatePtr,this._temporalKinematicStatePtr,this._worldTransformPtr)}getTotalForceToRef(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait();const t=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyGetTotalForce(this._inner.ptr,t.byteOffset),e.set(t[0],t[1],t[2])}getTotalTorqueToRef(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait();const t=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyGetTotalTorque(this._inner.ptr,t.byteOffset),e.set(t[0],t[1],t[2])}applyCentralForce(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyApplyCentralForce(this._inner.ptr,e.x,e.y,e.z)}applyTorque(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyApplyTorque(this._inner.ptr,e.x,e.y,e.z)}applyForce(e,t){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait();const r=this._inner.vector3Buffer1.array;r[0]=e.x,r[1]=e.y,r[2]=e.z;const n=this._inner.vector3Buffer2.array;n[0]=t.x,n[1]=t.y,n[2]=t.z,this.runtime.wasmInstance.rigidBodyApplyForce(this._inner.ptr,r.byteOffset,n.byteOffset)}applyCentralImpulse(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyApplyCentralImpulse(this._inner.ptr,e.x,e.y,e.z)}applyTorqueImpulse(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyApplyTorqueImpulse(this._inner.ptr,e.x,e.y,e.z)}applyImpulse(e,t){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait();const r=this._inner.vector3Buffer1.array;r[0]=e.x,r[1]=e.y,r[2]=e.z;const n=this._inner.vector3Buffer2.array;n[0]=t.x,n[1]=t.y,n[2]=t.z,this.runtime.wasmInstance.rigidBodyApplyImpulse(this._inner.ptr,r.byteOffset,n.byteOffset)}applyPushImpulse(e,t){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait();const r=this._inner.vector3Buffer1.array;r[0]=e.x,r[1]=e.y,r[2]=e.z;const n=this._inner.vector3Buffer2.array;n[0]=t.x,n[1]=t.y,n[2]=t.z,this.runtime.wasmInstance.rigidBodyApplyPushImpulse(this._inner.ptr,r.byteOffset,n.byteOffset)}getPushVelocityToRef(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait();const t=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyGetPushVelocity(this._inner.ptr,t.byteOffset),e.set(t[0],t[1],t[2])}getTurnVelocityToRef(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait();const t=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyGetTurnVelocity(this._inner.ptr,t.byteOffset),e.set(t[0],t[1],t[2])}setPushVelocity(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodySetPushVelocity(this._inner.ptr,e.x,e.y,e.z)}setTurnVelocity(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodySetTurnVelocity(this._inner.ptr,e.x,e.y,e.z)}applyCentralPushImpulse(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyApplyCentralPushImpulse(this._inner.ptr,e.x,e.y,e.z)}applyTorqueTurnImpulse(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyApplyTorqueTurnImpulse(this._inner.ptr,e.x,e.y,e.z)}clearForces(){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyClearForces(this._inner.ptr)}getLinearVelocityToRef(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait();const t=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyGetLinearVelocity(this._inner.ptr,t.byteOffset),e.set(t[0],t[1],t[2])}getAngularVelocityToRef(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait();const t=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyGetAngularVelocity(this._inner.ptr,t.byteOffset),e.set(t[0],t[1],t[2])}setLinearVelocity(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodySetLinearVelocity(this._inner.ptr,e.x,e.y,e.z)}setAngularVelocity(e){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodySetAngularVelocity(this._inner.ptr,e.x,e.y,e.z)}getVelocityInLocalPointToRef(e,t){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait();const r=this._inner.vector3Buffer1.array,n=this._inner.vector3Buffer2.array;return r[0]=e.x,r[1]=e.y,r[2]=e.z,this.runtime.wasmInstance.rigidBodyGetVelocityInLocalPoint(this._inner.ptr,r.byteOffset,n.byteOffset),t.set(n[0],n[1],n[2])}getPushVelocityInLocalPointToRef(e,t){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait();const r=this._inner.vector3Buffer1.array,n=this._inner.vector3Buffer2.array;return r[0]=e.x,r[1]=e.y,r[2]=e.z,this.runtime.wasmInstance.rigidBodyGetPushVelocityInLocalPoint(this._inner.ptr,r.byteOffset,n.byteOffset),t.set(n[0],n[1],n[2])}getShape(){return this._nullCheck(),this._inner.getShapeReference()}setShape(e){if(this._nullCheck(),e.runtime!==this.runtime)throw new Error("Cannot set shape from different runtime");this._inner.hasReferences&&this.runtime.lock.wait(),this._inner.setShapeReference(e),this.runtime.wasmInstance.rigidBodySetShape(this._inner.ptr,e.ptr)}}},4444:(e,t,r)=>{r.d(t,{x:()=>i});var n=r(9923);class i{shouldSync;constructor(){this.shouldSync=!0}setTransformMatrixFromArray(e,t,r,n){const i=e.array;i[4]=r[n],i[8]=r[n+1],i[12]=r[n+2],i[5]=r[n+4],i[9]=r[n+5],i[13]=r[n+6],i[6]=r[n+8],i[10]=r[n+9],i[14]=r[n+10],i[16]=r[n+12],i[17]=r[n+13],i[18]=r[n+14];const s=t.array;0!==s[0]&&(s[0]=2)}setDynamicTransformMatrixFromArray(e,t,r){const n=e.array;n[0]=t[r],n[16]=t[r+1],n[32]=t[r+2],n[1]=t[r+4],n[17]=t[r+5],n[33]=t[r+6],n[2]=t[r+8],n[18]=t[r+9],n[34]=t[r+10],n[48]=t[r+12],n[49]=t[r+13],n[50]=t[r+14]}setDamping(e,t,r,n){e.rigidBodySetDamping(t,r,n)}getLinearDamping(e,t){return e.rigidBodyGetLinearDamping(t)}getAngularDamping(e,t){return e.rigidBodyGetAngularDamping(t)}setMassProps(e,t,r,n){e.rigidBodySetMassProps(t,r,n.x,n.y,n.z)}getMass(e,t){return e.rigidBodyGetMass(t)}getLocalInertia(e,t){const r=e.allocateBuffer(12),i=e.createTypedArray(Float32Array,r,3).array;e.rigidBodyGetLocalInertia(t,r);const s=new n.Pq(i[0],i[1],i[2]);return e.deallocateBuffer(r,12),s}translate(e,t,r){e.rigidBodyTranslate(t,r.x,r.y,r.z)}}},5228:(e,t,r)=>{r.d(t,{R:()=>i});var n=r(9923);class i{shouldSync;_count;constructor(e){this.shouldSync=!0,this._count=e}setTransformMatrixFromArray(e,t,r,n,i){const s=e.array,a=20*r;s[a+4+0]=n[i],s[a+8+0]=n[i+1],s[a+12+0]=n[i+2],s[a+4+1]=n[i+4],s[a+8+1]=n[i+5],s[a+12+1]=n[i+6],s[a+4+2]=n[i+8],s[a+8+2]=n[i+9],s[a+12+2]=n[i+10],s[a+16+0]=n[i+12],s[a+16+1]=n[i+13],s[a+16+2]=n[i+14];const h=t.array;0!==h[r]&&(h[r]=2)}setTransformMatricesFromArray(e,t,r,n){const i=e.array,s=t.array,a=this._count;let h=0,o=n;for(let e=0;e<a;++e)i[h+4+0]=r[o],i[h+8+0]=r[o+1],i[h+12+0]=r[o+2],i[h+4+1]=r[o+4],i[h+8+1]=r[o+5],i[h+12+1]=r[o+6],i[h+4+2]=r[o+8],i[h+8+2]=r[o+9],i[h+12+2]=r[o+10],i[h+16+0]=r[o+12],i[h+16+1]=r[o+13],i[h+16+2]=r[o+14],0!==s[e]&&(s[e]=2),h+=20,o+=16}setDynamicTransformMatrixFromArray(e,t,r,n){const i=e[t].array;i[0]=r[n],i[16]=r[n+1],i[32]=r[n+2],i[1]=r[n+4],i[17]=r[n+5],i[33]=r[n+6],i[2]=r[n+8],i[18]=r[n+9],i[34]=r[n+10],i[48]=r[n+12],i[49]=r[n+13],i[50]=r[n+14]}setDamping(e,t,r,n,i){e.rigidBodyBundleSetDamping(t,r,n,i)}getLinearDamping(e,t,r){return e.rigidBodyBundleGetLinearDamping(t,r)}getAngularDamping(e,t,r){return e.rigidBodyBundleGetAngularDamping(t,r)}setMassProps(e,t,r,n,i){e.rigidBodyBundleSetMassProps(t,r,n,i.x,i.y,i.z)}getMass(e,t,r){return e.rigidBodyBundleGetMass(t,r)}getLocalInertia(e,t,r){const i=e.allocateBuffer(12),s=e.createTypedArray(Float32Array,i,3).array;e.rigidBodyBundleGetLocalInertia(t,r,i);const a=new n.Pq(s[0],s[1],s[2]);return e.deallocateBuffer(i,12),a}translate(e,t,r,n){e.rigidBodyBundleTranslate(t,r,n.x,n.y,n.z)}}},5901:(e,t,r)=>{r.d(t,{t:()=>h});var n=r(9923);class i{_wasmInstance;_ptr;_shapeReference;constructor(e,t){this._wasmInstance=e,this._ptr=t,this._shapeReference=null}dispose(){0!==this._ptr&&(this._wasmInstance.deref()?.deallocateBuffer(this._ptr,144),this._ptr=0,this._shapeReference&&this._shapeReference.removeReference(),this._shapeReference=null)}get ptr(){return this._ptr}get shape(){return this._shapeReference}set shape(e){this._shapeReference&&this._shapeReference.removeReference(),this._shapeReference=e,this._shapeReference&&this._shapeReference.addReference()}}function s(e){e.dispose()}const a=new WeakMap;class h{_wasmInstance;_uint32Ptr;_float32Ptr;_uint8Ptr;_uint16Ptr;_inner;constructor(e){this._wasmInstance=e;const t=e.allocateBuffer(144);this._uint32Ptr=e.createTypedArray(Uint32Array,t,36),this._float32Ptr=e.createTypedArray(Float32Array,t,36),this._uint8Ptr=e.createTypedArray(Uint8Array,t,144),this._uint16Ptr=e.createTypedArray(Uint16Array,t,72),this._inner=new i(new WeakRef(e),t);const r=this._uint32Ptr.array,n=this._float32Ptr.array,h=this._uint8Ptr.array,o=this._uint16Ptr.array;r[0]=0,n[4]=1,n[5]=0,n[6]=0,n[7]=0,n[8]=0,n[9]=1,n[10]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=1,n[15]=0,n[16]=0,n[17]=0,n[18]=0,n[19]=1,o[40]=0,h[82]=0,n[21]=1,n[22]=0,n[23]=0,n[24]=0,n[25]=0,n[26]=0,n[27]=.5,n[28]=0,n[29]=0,n[30]=1,o[62]=1,o[63]=65535,h[128]=0,h[129]=0,h[130]=0;let c=a.get(e);void 0===c&&(c=new FinalizationRegistry(s),a.set(e,c)),c.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=a.get(this._wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed RigidBodyConstructionInfo")}get shape(){return this._nullCheck(),this._inner.shape}set shape(e){this._nullCheck(),this._inner.shape=e,this._uint32Ptr.array[0]=e?e.ptr:0}getInitialTransformToRef(e){this._nullCheck();const t=this._float32Ptr.array;return e.set(t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15],t[16],t[17],t[18],t[19]),e}setInitialTransform(e){this._nullCheck();const t=this._float32Ptr.array;e.copyToArray(t,4)}get motionType(){return this._nullCheck(),this._uint8Ptr.array[82]}set motionType(e){this._nullCheck(),this._uint8Ptr.array[82]=e}get mass(){return this._nullCheck(),this._float32Ptr.array[21]}set mass(e){this._nullCheck(),this._float32Ptr.array[21]=e}get localInertia(){if(this._nullCheck(),!(1&this._uint16Ptr.array[40]))return null;const e=this._float32Ptr.array,t=e[22],r=e[23],i=e[24];return new n.Pq(t,r,i)}set localInertia(e){if(this._nullCheck(),null===e)return void(this._uint16Ptr.array[40]&=-2);this._uint16Ptr.array[40]|=1;const t=this._float32Ptr.array;t[22]=e.x,t[23]=e.y,t[24]=e.z}get linearDamping(){return this._nullCheck(),this._float32Ptr.array[25]}set linearDamping(e){this._nullCheck(),this._float32Ptr.array[25]=e}get angularDamping(){return this._nullCheck(),this._float32Ptr.array[26]}set angularDamping(e){this._nullCheck(),this._float32Ptr.array[26]=e}get friction(){return this._nullCheck(),this._float32Ptr.array[27]}set friction(e){this._nullCheck(),this._float32Ptr.array[27]=e}get restitution(){return this._nullCheck(),this._float32Ptr.array[28]}set restitution(e){this._nullCheck(),this._float32Ptr.array[28]=e}get linearSleepingThreshold(){return this._nullCheck(),this._float32Ptr.array[29]}set linearSleepingThreshold(e){this._nullCheck(),this._float32Ptr.array[29]=e}get angularSleepingThreshold(){return this._nullCheck(),this._float32Ptr.array[30]}set angularSleepingThreshold(e){this._nullCheck(),this._float32Ptr.array[30]=e}get collisionGroup(){return this._nullCheck(),this._uint16Ptr.array[62]}set collisionGroup(e){this._nullCheck(),this._uint16Ptr.array[62]=e}get collisionMask(){return this._nullCheck(),this._uint16Ptr.array[63]}set collisionMask(e){this._nullCheck(),this._uint16Ptr.array[63]=e}get additionalDamping(){return this._nullCheck(),!!this._uint8Ptr.array[128]}set additionalDamping(e){this._nullCheck(),this._uint8Ptr.array[128]=+e}get noContactResponse(){return this._nullCheck(),!!this._uint8Ptr.array[129]}set noContactResponse(e){this._nullCheck(),this._uint8Ptr.array[129]=+e}get disableDeactivation(){return this._nullCheck(),!!this._uint8Ptr.array[130]}set disableDeactivation(e){this._nullCheck(),this._uint8Ptr.array[130]=+e}}},6405:(e,t,r)=>{r.d(t,{MU:()=>c,O4:()=>o,SA:()=>h,Ty:()=>l});class n{_wasmInstance;_ptr;_referenceCount;constructor(e,t){this._wasmInstance=e,this._ptr=t,this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose shape while it still has references");0!==this._ptr&&(this._wasmInstance.deref()?.destroyShape(this._ptr),this._ptr=0)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}}function i(e){e.dispose()}const s=new WeakMap;class a{runtime;_inner;constructor(e,t){this.runtime=e,this._inner=new n(new WeakRef(e.wasmInstance),t);let r=s.get(e.wasmInstance);void 0===r&&(r=new FinalizationRegistry(i),s.set(e.wasmInstance,r)),r.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}}class h extends a{constructor(e,t){const r=e.wasmInstance.createBoxShape(t.x,t.y,t.z);super(e,r)}}class o extends a{constructor(e,t){const r=e.wasmInstance.createSphereShape(t);super(e,r)}}class c extends a{constructor(e,t,r){const n=e.wasmInstance.createCapsuleShape(t,r);super(e,n)}}class l extends a{constructor(e,t,r){const n=e.wasmInstance.createStaticPlaneShape(t.x,t.y,t.z,r);super(e,n)}}},6738:(e,t,r)=>{r.d(t,{e:()=>a});class n{array;constructor(e,t,r,n){this.array=new e(t.buffer,r,n)}}class i{_memory;_byteOffset;_length;_array;constructor(e,t,r,n){this._memory=t,this._byteOffset=r,this._length=n,this._array=0===n?new e(0):new e(t.buffer,r,n)}get array(){return this._array.length!==this._length&&(this._array=new this._array.constructor(this._memory.buffer,this._byteOffset,this._length)),this._array}}const s=new WeakMap;async function a(e,t=navigator.hardwareConcurrency){const r=e.getWasmInstanceInner();{const e=s.get(r);if(void 0!==e)return e}let a=null;s.set(r,new Promise((e=>a=e)));const h={...r},o=await h.default({});h.init();const c=o.memory;return h.memory=c,c.buffer instanceof ArrayBuffer?h.createTypedArray=function(e,t,r){return new i(e,c,t,r)}:h.createTypedArray=function(e,t,r){return new n(e,c,t,r)},await(h.initThreadPool?.(t)),a(h),h}}}]);