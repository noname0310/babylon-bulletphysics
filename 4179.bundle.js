"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[4179],{67168:(e,t,n)=>{n.d(t,{vC:()=>a});class r{_wasmInstance;_ptr;_bodyReference;_referenceCount;constructor(e,t,n){this._wasmInstance=e,this._ptr=t,this._bodyReference=n,Array.isArray(n)?(n[0].addReference(),n[1].addReference()):n.addReference(),this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose constraint while it still has references");0!==this._ptr&&(this._wasmInstance.deref()?.destroyConstraint(this._ptr),this._ptr=0,Array.isArray(this._bodyReference)?(this._bodyReference[0].removeReference(),this._bodyReference[1].removeReference()):this._bodyReference.removeReference(),this._bodyReference=null)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}}function i(e){e.dispose()}const s=new WeakMap;class o{runtime;_inner;_worldReference;constructor(e,t,n){if(Array.isArray(n)){if(n[0].runtime!==e||n[1].runtime!==e)throw new Error("Cannot create constraint between bodies from different runtimes")}else if(n.runtime!==e)throw new Error("Cannot create constraint between body and bundle from different runtimes");this.runtime=e,this._inner=new r(new WeakRef(e.wasmInstance),t,n),this._worldReference=null;let o=s.get(e.wasmInstance);void 0===o&&(o=new FinalizationRegistry(i),s.set(e.wasmInstance,o)),o.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add constraint to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}}class a extends o{constructor(e,t,n,r,i,s){const o=e.wasmInstance,a=o.allocateBuffer(64),c=o.createTypedArray(Float32Array,a,16);r.copyToArray(c.array);const h=o.allocateBuffer(64),d=o.createTypedArray(Float32Array,h,16);i.copyToArray(d.array);const l=Array.isArray(n),f=l?o.createGeneric6DofSpringConstraintFromBundle(t.ptr,n[0],n[1],a,h,s):o.createGeneric6DofSpringConstraint(t.ptr,n.ptr,a,h,s);o.deallocateBuffer(a,64),o.deallocateBuffer(h,64),super(e,f,l?t:[t,n])}setLinearLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setLinearUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearUpperLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularUpperLimit(this._inner.ptr,e.x,e.y,e.z)}enableSpring(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintEnableSpring(this._inner.ptr,e,t)}setStiffness(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetStiffness(this._inner.ptr,e,t)}setDamping(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetDamping(this._inner.ptr,e,t)}}},1592:(e,t,n)=>{n.d(t,{U:()=>o});class r{_wasmInstance;_ptr;_shapeReference;_referenceCount;_shadowCount;constructor(e,t,n){this._wasmInstance=e,this._ptr=t,this._shapeReference=n,n.addReference(),this._referenceCount=0,this._shadowCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose rigid body while it still has references");if(this._shadowCount>0)throw new Error("Cannot dispose rigid body while it still has shadows");0!==this._ptr&&(this._wasmInstance.deref()?.destroyRigidBody(this._ptr),this._ptr=0,this._shapeReference.removeReference(),this._shapeReference=null)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}addShadow(){this._shadowCount+=1}removeShadow(){this._shadowCount-=1}get hasShadows(){return 0<this._shadowCount}}function i(e){e.dispose()}const s=new WeakMap;class o{runtime;_motionStatePtr;_bufferedMotionStatePtr;_inner;_worldReference;impl;isDynamic;constructor(e,t,n){const o=void 0!==n?t.getPtr(n):t.ptr;if(0===o)throw new Error("Cannot create rigid body with null pointer");let a;if(a=void 0!==n?t.getShape(n):t.shape,null===a)throw new Error("Cannot create rigid body with null shape");if(a.runtime!==e)throw new Error("Cannot create rigid body with shapes from different runtimes");this.runtime=e;const c=e.wasmInstance,h=c.createRigidBody(o),d=c.rigidBodyGetMotionStatePtr(h);this._motionStatePtr=c.createTypedArray(Float32Array,d,20);const l=c.rigidBodyGetBufferedMotionStatePtr(h);this._bufferedMotionStatePtr=c.createTypedArray(Float32Array,l,20),this._inner=new r(new WeakRef(e.wasmInstance),h,a),this._worldReference=null;let f=s.get(c);void 0===f&&(f=new FinalizationRegistry(i),s.set(c,f)),f.register(this,this._inner,this),this.impl=e.createRigidBodyImpl(),this.isDynamic=void 0!==n?0===t.getMotionType(n):0===t.motionType}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}addShadowReference(){this._inner.addShadow()}removeShadowReference(){this._inner.removeShadow()}get hasShadows(){return this._inner.hasShadows}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add rigid body to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==this._worldReference?this._inner.addReference():this._inner.removeReference())}getWorldReference(){return this._worldReference}updateBufferedMotionState(e){if(this._nullCheck(),e){const e=this.runtime.wasmInstance.rigidBodyGetMotionStatePtr(this._inner.ptr);this._bufferedMotionStatePtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20)}else{const e=this.runtime.wasmInstance.rigidBodyGetBufferedMotionStatePtr(this._inner.ptr);this._bufferedMotionStatePtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20)}}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed rigid body")}makeKinematic(){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyMakeKinematic(this._inner.ptr)}restoreDynamic(){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyRestoreDynamic(this._inner.ptr)}getTransformMatrixToRef(e){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const t=this._bufferedMotionStatePtr.array;return e.set(t[4],t[8],t[12],0,t[5],t[9],t[13],0,t[6],t[10],t[14],0,t[16],t[17],t[18],1)}getTransformMatrixToArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const n=this._bufferedMotionStatePtr.array;e[t+0]=n[4],e[t+1]=n[8],e[t+2]=n[12],e[t+3]=0,e[t+4]=n[5],e[t+5]=n[9],e[t+6]=n[13],e[t+7]=0,e[t+8]=n[6],e[t+9]=n[10],e[t+10]=n[14],e[t+11]=0,e[t+12]=n[16],e[t+13]=n[17],e[t+14]=n[18],e[t+15]=1}setTransformMatrix(e){this.setTransformMatrixFromArray(e.m,0)}setTransformMatrixFromArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatrixFromArray(this._motionStatePtr,e,t)}}},84179:(e,t,n)=>{n.r(t),n.d(t,{SceneBuilder:()=>T}),n(90203),n(33832),n(2093);var r=n(8943),i=n(7839),s=n(52046),o=n(71513),a=n(18595),c=n(26041),h=n(79923),d=n(96793),l=n(58144),f=n(87491),u=n(46738),w=n(67168),m=n(2090),p=n(27744),_=n(91167),y=n(15733),R=n(26405),g=n(1592),S=n(35901),b=n(89800),C=n(32399);class T{async build(e,t){const n=new f.Z(t);n.clearColor=new c.ov(.95,.95,.95,1);const T=new i.L("arcRotateCamera",0,0,500,new h.Pq(0,0,0),n);T.minZ=1,T.maxZ=3e3,T.setPosition(new h.Pq(60,40,-50).scaleInPlace(10)),T.attachControl(void 0,!1),T.inertia=.8,T.speed=10;const I=new o.g("hemisphericLight",new h.Pq(0,1,0),n);I.intensity=.5,I.specular=new c.v9(0,0,0),I.groundColor=new c.v9(1,1,1);const A=new s.Z("directionalLight",new h.Pq(.5,-1,1),n);A.intensity=.5;A.shadowMaxZ=250,A.shadowMinZ=-250,A.autoCalcShadowZBounds=!1,A.autoUpdateExtends=!1,A.shadowOrthoScale=0,A.orthoTop=250,A.orthoBottom=-250,A.orthoLeft=-250,A.orthoRight=250;const P=new a.o(2048,A,!0);P.transparencyShadow=!0,P.usePercentageCloserFiltering=!0,P.forceBackFacesOnly=!1,P.bias=.004,P.filteringQuality=a.o.QUALITY_MEDIUM;const x=parseInt(prompt("Thread count","2"));console.log("Thread count:",x);const M=1===x?await(0,u.e)(new _.Z):await(0,u.e)(new p.t,x),v=new m.D(M),k=new y.F(v,!0),L=new h.uq;{const e=(0,l.x)("ground",{size:500},n);e.rotationQuaternion=h.PT.RotationAxis(new h.Pq(1,0,0),Math.PI/2),P.addShadowCaster(e),e.receiveShadows=!0;const t=new R.Ty(v,new h.Pq(0,0,-1),0),r=new S.t(M);r.shape=t,h.uq.FromQuaternionToRef(e.rotationQuaternion,L),r.setInitialTransform(L),r.motionType=1;const i=new g.U(v,r);k.addRigidBodyToGlobal(i)}const B=512,q=[],F=[];if("u"===prompt("Shape type (u, r) uniform box, random","u")){const e=new h.Pq(1,1,1),t=new R.SA(v,e),n={type:"box",size:e};for(let e=0;e<B;++e)q.push(t),F.push(n)}else{const e=new C.q(0);for(let t=0;t<B;++t){const t=2*e.next()|0;if(0===t){const t=2*e.next()+.5,n=2*e.next()+.5,r=2*e.next()+.5,i=new h.Pq(t,n,r);q.push(new R.SA(v,i)),F.push({type:"box",size:i})}else{if(1!==t)throw new Error("Invalid type");{const t=2*e.next()+1;q.push(new R.O4(v,t)),F.push({type:"sphere",radius:t})}}}}const E=[];for(let e=0;e<4;++e)for(let t=0;t<8;++t){const n=8*e+t,r=60*(t-4)+30,i=60*(e-2)+30,s=[];for(let e=0;e<B;++e){const t=new S.t(M);t.shape=q[e];const n=h.uq.TranslationToRef(r,1+2*e,i,L);t.setInitialTransform(n),t.friction=1,t.linearDamping=.3,t.angularDamping=.3,s.push(t)}for(let e=0;e<B;++e){const t=s[e],r=new g.U(v,t);k.addRigidBody(r,n),E.push(r)}for(let e=0;e<B;e+=2){const t=[n*B+e,n*B+e+1],r=new w.vC(v,E[t[0]],E[t[1]],h.uq.Translation(0,-1.2,0),h.uq.Translation(0,1.2,0),!0);r.setLinearLowerLimit(new h.Pq(0,0,0)),r.setLinearUpperLimit(new h.Pq(0,0,0)),r.setAngularLowerLimit(new h.Pq(Math.PI/4,0,0)),r.setAngularUpperLimit(new h.Pq(0,0,0));for(let e=0;e<6;++e)r.enableSpring(e,!0),r.setStiffness(e,100),r.setDamping(e,1);k.addConstraint(r,n,!0)}}console.log("Rigid body count:",16384);const D=[],U=(0,d.an)("baseBox",{size:1},n),z=(0,r._6X)("baseSphere",{diameter:1},n);U.setEnabled(!1),z.setEnabled(!1),U.receiveShadows=!0,z.receiveShadows=!0;for(let e=0;e<16384;++e){const t=F[e%F.length],n="box"===t.type?U.createInstance(`boxInstance${e}`):z.createInstance(`sphereInstance${e}`);P.addShadowCaster(n),n.scaling.copyFrom("box"===t.type?t.size.scale(2):new h.Pq(t.radius,t.radius,t.radius).scale(2)),n.rotationQuaternion=h.PT.Identity(),D.push(n)}return new b.X((()=>{const e=performance.now();k.stepSimulation(1/60,10,1/60);for(let e=0;e<E.length;++e){E[e].getTransformMatrixToRef(L);const t=D[e];L.getTranslationToRef(t.position),h.PT.FromRotationMatrixToRef(L,t.rotationQuaternion)}const t=performance.now(),r=t-e;return n.render(),[r,performance.now()-t]})).runBench(),n.onBeforeRenderObservable.add((()=>{k.stepSimulation(1/60,10,1/60);for(let e=0;e<E.length;++e){E[e].getTransformMatrixToRef(L);const t=D[e];L.getTranslationToRef(t.position),h.PT.FromRotationMatrixToRef(L,t.rotationQuaternion)}})),n}}},32399:(e,t,n)=>{n.d(t,{q:()=>r});class r{_a;constructor(e){this._a=e}next(){let e=this._a+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296}}}}]);