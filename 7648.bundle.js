"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[7648],{7648:(e,t,r)=>{r.d(t,{Y:()=>o});class n{_wasmInstance;_ptr;_vector3Buffer1;_vector3Buffer2;_shapeReferences;_referenceCount;_shadowCount;constructor(e,t,r){this._wasmInstance=new WeakRef(e),this._ptr=t;const n=e.allocateBuffer(12);this._vector3Buffer1=e.createTypedArray(Float32Array,n,3);const i=e.allocateBuffer(12);this._vector3Buffer2=e.createTypedArray(Float32Array,i,3),this._shapeReferences=r;for(const e of r)e.addReference();this._referenceCount=0,this._shadowCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose rigid body bundle while it still has references");if(0===this._ptr)return;const e=this._wasmInstance.deref();void 0!==e&&(e.deallocateBuffer(this._vector3Buffer1.array.byteOffset,12),e.deallocateBuffer(this._vector3Buffer2.array.byteOffset,12),e.destroyRigidBodyBundle(this._ptr)),this._ptr=0;for(const e of this._shapeReferences)e.removeReference();this._shapeReferences.clear()}get ptr(){return this._ptr}get vector3Buffer1(){return this._vector3Buffer1}get vector3Buffer2(){return this._vector3Buffer2}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}addShadow(){this._shadowCount+=1}removeShadow(){this._shadowCount-=1}get hasShadows(){return 0<this._shadowCount}}function i(e){e.dispose()}const s=new WeakMap;class o{runtime;_motionStatesPtr;_bufferedMotionStatesPtr;_worldTransformPtrArray;_temporalKinematicStatesPtr;_inner;_count;_worldReference;impl;isContainsDynamic;constructor(e,t){if(0===t.ptr)throw new Error("Cannot create rigid body bundle with null pointer");const r=t.count,o=new Set;for(let n=0;n<r;++n){const r=t.getShape(n);if(null===r)throw new Error("Cannot create rigid body bundle with null shape");if(r.runtime!==e)throw new Error("Cannot create rigid body bundle with shapes from different runtimes");o.add(r)}this.runtime=e;const a=e.wasmInstance,h=a.createRigidBodyBundle(t.ptr,r),c=a.rigidBodyBundleGetMotionStatesPtr(h);this._motionStatesPtr=a.createTypedArray(Float32Array,c,20*r);const u=a.rigidBodyBundleGetBufferedMotionStatesPtr(h);this._bufferedMotionStatesPtr=a.createTypedArray(Float32Array,u,20*r);const l=[];let f=!1;for(let e=0;e<r;++e)if(0===t.getMotionType(e)){f=!0;const t=a.rigidBodyBundleGetWorldTransformPtr(h,e);l.push(a.createTypedArray(Float32Array,t,16))}else l.push(null);this._worldTransformPtrArray=l;const m=a.rigidBodyBundleGetTemporalKinematicStatesPtr(h);this._temporalKinematicStatesPtr=a.createTypedArray(Uint8Array,m,r),this._inner=new n(e.wasmInstance,h,o),this._count=r,this._worldReference=null;let d=s.get(a);void 0===d&&(d=new FinalizationRegistry(i),s.set(a,d)),d.register(this,this._inner,this),this.impl=e.createRigidBodyBundleImpl(this),this.isContainsDynamic=f}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}get count(){return this._count}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}addShadowReference(){this._inner.addShadow()}removeShadowReference(){this._inner.removeShadow()}get hasShadows(){return this._inner.hasShadows}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add rigid body bundle to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}getWorldReference(){return this._worldReference}updateBufferedMotionStates(e){if(this._nullCheck(),e){const e=this.runtime.wasmInstance.rigidBodyBundleGetMotionStatesPtr(this._inner.ptr);this._bufferedMotionStatesPtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20*this._count)}else{const e=this.runtime.wasmInstance.rigidBodyBundleGetBufferedMotionStatesPtr(this._inner.ptr);this._bufferedMotionStatesPtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20*this._count)}}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed rigid body bundle")}getTransformMatrixToRef(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatesPtr.array,n=20*e;return t.set(r[n+4+0],r[n+8+0],r[n+12+0],0,r[n+4+1],r[n+8+1],r[n+12+1],0,r[n+4+2],r[n+8+2],r[n+12+2],0,r[n+16+0],r[n+16+1],r[n+16+2],1)}getTransformMatrixToArray(e,t,r=0){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const n=this._bufferedMotionStatesPtr.array,i=20*e;t[r+0]=n[i+4+0],t[r+1]=n[i+8+0],t[r+2]=n[i+12+0],t[r+3]=0,t[r+4]=n[i+4+1],t[r+5]=n[i+8+1],t[r+6]=n[i+12+1],t[r+7]=0,t[r+8]=n[i+4+2],t[r+9]=n[i+8+2],t[r+10]=n[i+12+2],t[r+11]=0,t[r+12]=n[i+16+0],t[r+13]=n[i+16+1],t[r+14]=n[i+16+2],t[r+15]=1}getTransformMatricesToArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatesPtr.array,n=this._count;let i=0,s=t;for(let t=0;t<n;++t)e[s+0]=r[i+4+0],e[s+1]=r[i+8+0],e[s+2]=r[i+12+0],e[s+3]=0,e[s+4]=r[i+4+1],e[s+5]=r[i+8+1],e[s+6]=r[i+12+1],e[s+7]=0,e[s+8]=r[i+4+2],e[s+9]=r[i+8+2],e[s+10]=r[i+12+2],e[s+11]=0,e[s+12]=r[i+16+0],e[s+13]=r[i+16+1],e[s+14]=r[i+16+2],e[s+15]=1,i+=20,s+=16}setTransformMatrix(e,t){this.setTransformMatrixFromArray(e,t.m,0)}setTransformMatrixFromArray(e,t,r=0){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatrixFromArray(this._motionStatesPtr,this._temporalKinematicStatesPtr,e,t,r)}setTransformMatricesFromArray(e,t=0){if(this._nullCheck(),e.length<16*this._count)throw new RangeError("Array is too short");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatricesFromArray(this._motionStatesPtr,this._temporalKinematicStatesPtr,e,t)}setDynamicTransformMatrix(e,t,r=!1){this.setDynamicTransformMatrixFromArray(e,t.m,0,r)}setDynamicTransformMatrixFromArray(e,t,r=0,n=!1){if(null===this._worldTransformPtrArray[e]){if(n)return void this.setTransformMatrixFromArray(e,t,r);throw new Error("Cannot set dynamic transform of non-dynamic body")}if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setDynamicTransformMatrixFromArray(this._worldTransformPtrArray,e,t,r)}setDamping(e,t,r){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setDamping(this.runtime.wasmInstance,this._inner.ptr,e,t,r)}getLinearDamping(e){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");return this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.getLinearDamping(this.runtime.wasmInstance,this._inner.ptr,e)}getAngularDamping(e){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");return this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.getAngularDamping(this.runtime.wasmInstance,this._inner.ptr,e)}setMassProps(e,t,r){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setMassProps(this.runtime.wasmInstance,this._inner.ptr,e,t,r)}getMass(e){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");return this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.getMass(this.runtime.wasmInstance,this._inner.ptr,e)}getLocalInertia(e){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");return this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.getLocalInertia(this.runtime.wasmInstance,this._inner.ptr,e)}translate(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.translate(this.runtime.wasmInstance,this._inner.ptr,e,t)}get needToCommit(){return this.impl.needToCommit??!1}commitToWasm(){if(void 0===this.impl.commitToWasm)throw new Error("commit only avalible on buffered evaluation mode");this._nullCheck(),this.runtime.lock.wait(),this.impl.commitToWasm(this.runtime.wasmInstance,this._inner.ptr,this._motionStatesPtr,this._temporalKinematicStatesPtr,this._worldTransformPtrArray)}getTotalForceToRef(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait();const r=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyBundleGetTotalForce(this._inner.ptr,e,r.byteOffset),t.copyFromFloats(r[0],r[1],r[2])}getTotalTorqueToRef(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait();const r=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyBundleGetTotalTorque(this._inner.ptr,e,r.byteOffset),t.copyFromFloats(r[0],r[1],r[2])}applyCentralForce(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleApplyCentralForce(this._inner.ptr,e,t.x,t.y,t.z)}applyTorque(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleApplyTorque(this._inner.ptr,e,t.x,t.y,t.z)}applyForce(e,t,r){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait();const n=this._inner.vector3Buffer1.array;n[0]=t.x,n[1]=t.y,n[2]=t.z;const i=this._inner.vector3Buffer2.array;i[0]=r.x,i[1]=r.y,i[2]=r.z,this.runtime.wasmInstance.rigidBodyBundleApplyForce(this._inner.ptr,e,n.byteOffset,i.byteOffset)}applyCentralImpulse(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleApplyCentralImpulse(this._inner.ptr,e,t.x,t.y,t.z)}applyTorqueImpulse(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleApplyTorqueImpulse(this._inner.ptr,e,t.x,t.y,t.z)}applyImpulse(e,t,r){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait();const n=this._inner.vector3Buffer1.array;n[0]=t.x,n[1]=t.y,n[2]=t.z;const i=this._inner.vector3Buffer2.array;i[0]=r.x,i[1]=r.y,i[2]=r.z,this.runtime.wasmInstance.rigidBodyBundleApplyImpulse(this._inner.ptr,e,n.byteOffset,i.byteOffset)}applyPushImpulse(e,t,r){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait();const n=this._inner.vector3Buffer1.array;n[0]=t.x,n[1]=t.y,n[2]=t.z;const i=this._inner.vector3Buffer2.array;i[0]=r.x,i[1]=r.y,i[2]=r.z,this.runtime.wasmInstance.rigidBodyBundleApplyPushImpulse(this._inner.ptr,e,n.byteOffset,i.byteOffset)}getPushVelocityToRef(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait();const r=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyBundleGetPushVelocity(this._inner.ptr,e,r.byteOffset),t.copyFromFloats(r[0],r[1],r[2])}getTurnVelocityToRef(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait();const r=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyBundleGetTurnVelocity(this._inner.ptr,e,r.byteOffset),t.copyFromFloats(r[0],r[1],r[2])}setPushVelocity(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleSetPushVelocity(this._inner.ptr,e,t.x,t.y,t.z)}setTurnVelocity(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleSetTurnVelocity(this._inner.ptr,e,t.x,t.y,t.z)}applyCentralPushImpulse(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleApplyCentralPushImpulse(this._inner.ptr,e,t.x,t.y,t.z)}applyTorqueTurnImpulse(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleApplyTorqueTurnImpulse(this._inner.ptr,e,t.x,t.y,t.z)}clearForces(e){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleClearForces(this._inner.ptr,e)}getLinearVelocityToRef(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait();const r=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyBundleGetLinearVelocity(this._inner.ptr,e,r.byteOffset),t.copyFromFloats(r[0],r[1],r[2])}getAngularVelocityToRef(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait();const r=this._inner.vector3Buffer1.array;return this.runtime.wasmInstance.rigidBodyBundleGetAngularVelocity(this._inner.ptr,e,r.byteOffset),t.copyFromFloats(r[0],r[1],r[2])}setLinearVelocity(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleSetLinearVelocity(this._inner.ptr,e,t.x,t.y,t.z)}setAngularVelocity(e,t){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyBundleSetAngularVelocity(this._inner.ptr,e,t.x,t.y,t.z)}getVelocityInLocalPointToRef(e,t,r){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait();const n=this._inner.vector3Buffer1.array,i=this._inner.vector3Buffer2.array;return n[0]=t.x,n[1]=t.y,n[2]=t.z,this.runtime.wasmInstance.rigidBodyBundleGetVelocityInLocalPoint(this._inner.ptr,e,n.byteOffset,i.byteOffset),r.set(i[0],i[1],i[2])}getPushVelocityInLocalPointToRef(e,t,r){if(this._nullCheck(),e<0||this._count<=e)throw new RangeError("Index out of range");this._inner.hasReferences&&this.runtime.lock.wait();const n=this._inner.vector3Buffer1.array,i=this._inner.vector3Buffer2.array;return n[0]=t.x,n[1]=t.y,n[2]=t.z,this.runtime.wasmInstance.rigidBodyBundleGetPushVelocityInLocalPoint(this._inner.ptr,e,n.byteOffset,i.byteOffset),r.set(i[0],i[1],i[2])}}}}]);