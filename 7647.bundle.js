"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[7647],{67168:(e,t,r)=>{r.d(t,{o6:()=>c,vC:()=>h});class n{_wasmInstance;_ptr;_bodyReference;_referenceCount;constructor(e,t,r){this._wasmInstance=e,this._ptr=t,this._bodyReference=r,Array.isArray(r)?(r[0].addReference(),r[1].addReference()):r.addReference(),this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose constraint while it still has references");0!==this._ptr&&(this._wasmInstance.deref()?.destroyConstraint(this._ptr),this._ptr=0,Array.isArray(this._bodyReference)?(this._bodyReference[0].removeReference(),this._bodyReference[1].removeReference()):this._bodyReference.removeReference(),this._bodyReference=null)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}}function i(e){e.dispose()}const s=new WeakMap;class a{runtime;_inner;_worldReference;constructor(e,t,r){if(Array.isArray(r)){if(r[0].runtime!==e||r[1].runtime!==e)throw new Error("Cannot create constraint between bodies from different runtimes")}else if(r.runtime!==e)throw new Error("Cannot create constraint between body and bundle from different runtimes");this.runtime=e,this._inner=new n(new WeakRef(e.wasmInstance),t,r),this._worldReference=null;let a=s.get(e.wasmInstance);void 0===a&&(a=new FinalizationRegistry(i),s.set(e.wasmInstance,a)),a.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add constraint to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}}const o=64;class c extends a{constructor(e,t,r,n,i,s){const a=e.wasmInstance,c=a.allocateBuffer(o),h=a.createTypedArray(Float32Array,c,16);n.copyToArray(h.array);const d=a.allocateBuffer(o),m=a.createTypedArray(Float32Array,d,16);i.copyToArray(m.array);const l=Array.isArray(r),f=l?a.createGeneric6DofConstraintFromBundle(t.ptr,r[0],r[1],c,d,s):a.createGeneric6DofConstraint(t.ptr,r.ptr,c,d,s);a.deallocateBuffer(c,o),a.deallocateBuffer(d,o),super(e,f,l?t:[t,r])}setLinearLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setLinearUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearUpperLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularUpperLimit(this._inner.ptr,e.x,e.y,e.z)}}class h extends a{constructor(e,t,r,n,i,s){const a=e.wasmInstance,c=a.allocateBuffer(o),h=a.createTypedArray(Float32Array,c,16);n.copyToArray(h.array);const d=a.allocateBuffer(o),m=a.createTypedArray(Float32Array,d,16);i.copyToArray(m.array);const l=Array.isArray(r),f=l?a.createGeneric6DofSpringConstraintFromBundle(t.ptr,r[0],r[1],c,d,s):a.createGeneric6DofSpringConstraint(t.ptr,r.ptr,c,d,s);a.deallocateBuffer(c,o),a.deallocateBuffer(d,o),super(e,f,l?t:[t,r])}setLinearLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setLinearUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearUpperLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularUpperLimit(this._inner.ptr,e.x,e.y,e.z)}enableSpring(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintEnableSpring(this._inner.ptr,e,t)}setStiffness(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetStiffness(this._inner.ptr,e,t)}setDamping(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetDamping(this._inner.ptr,e,t)}}},1592:(e,t,r)=>{r.d(t,{U:()=>a});class n{_wasmInstance;_ptr;_shapeReference;_referenceCount;_shadowCount;constructor(e,t,r){this._wasmInstance=e,this._ptr=t,this._shapeReference=r,r.addReference(),this._referenceCount=0,this._shadowCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose rigid body while it still has references");if(this._shadowCount>0)throw new Error("Cannot dispose rigid body while it still has shadows");0!==this._ptr&&(this._wasmInstance.deref()?.destroyRigidBody(this._ptr),this._ptr=0,this._shapeReference.removeReference(),this._shapeReference=null)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}addShadow(){this._shadowCount+=1}removeShadow(){this._shadowCount-=1}get hasShadows(){return 0<this._shadowCount}}function i(e){e.dispose()}const s=new WeakMap;class a{runtime;_motionStatePtr;_bufferedMotionStatePtr;_worldTransformPtr;_temporalKinematicStatePtr;_inner;_worldReference;impl;isDynamic;constructor(e,t,r){const a=void 0!==r?t.getPtr(r):t.ptr;if(0===a)throw new Error("Cannot create rigid body with null pointer");let o;if(o=void 0!==r?t.getShape(r):t.shape,null===o)throw new Error("Cannot create rigid body with null shape");if(o.runtime!==e)throw new Error("Cannot create rigid body with shapes from different runtimes");const c=void 0!==r?0===t.getMotionType(r):0===t.motionType;this.runtime=e;const h=e.wasmInstance,d=h.createRigidBody(a),m=h.rigidBodyGetMotionStatePtr(d);this._motionStatePtr=h.createTypedArray(Float32Array,m,20);const l=h.rigidBodyGetBufferedMotionStatePtr(d);if(this._bufferedMotionStatePtr=h.createTypedArray(Float32Array,l,20),c){const e=h.rigidBodyGetWorldTransformPtr(d);this._worldTransformPtr=h.createTypedArray(Float32Array,e,16)}else this._worldTransformPtr=null;const f=h.rigidBodyGetTemporalKinematicStatePtr(d);this._temporalKinematicStatePtr=h.createTypedArray(Uint8Array,f,1),this._inner=new n(new WeakRef(e.wasmInstance),d,o),this._worldReference=null;let w=s.get(h);void 0===w&&(w=new FinalizationRegistry(i),s.set(h,w)),w.register(this,this._inner,this),this.impl=e.createRigidBodyImpl(),this.isDynamic=c}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}addShadowReference(){this._inner.addShadow()}removeShadowReference(){this._inner.removeShadow()}get hasShadows(){return this._inner.hasShadows}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add rigid body to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==this._worldReference?this._inner.addReference():this._inner.removeReference())}getWorldReference(){return this._worldReference}updateBufferedMotionState(e){if(this._nullCheck(),e){const e=this.runtime.wasmInstance.rigidBodyGetMotionStatePtr(this._inner.ptr);this._bufferedMotionStatePtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20)}else{const e=this.runtime.wasmInstance.rigidBodyGetBufferedMotionStatePtr(this._inner.ptr);this._bufferedMotionStatePtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20)}}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed rigid body")}getTransformMatrixToRef(e){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const t=this._bufferedMotionStatePtr.array;return e.set(t[4],t[8],t[12],0,t[5],t[9],t[13],0,t[6],t[10],t[14],0,t[16],t[17],t[18],1)}getTransformMatrixToArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatePtr.array;e[t+0]=r[4],e[t+1]=r[8],e[t+2]=r[12],e[t+3]=0,e[t+4]=r[5],e[t+5]=r[9],e[t+6]=r[13],e[t+7]=0,e[t+8]=r[6],e[t+9]=r[10],e[t+10]=r[14],e[t+11]=0,e[t+12]=r[16],e[t+13]=r[17],e[t+14]=r[18],e[t+15]=1}setTransformMatrix(e){this.setTransformMatrixFromArray(e.m,0)}setTransformMatrixFromArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatrixFromArray(this._motionStatePtr,this._temporalKinematicStatePtr,e,t)}setDynamicTransformMatrix(e){this.setDynamicTransformMatrixFromArray(e.m,0)}setDynamicTransformMatrixFromArray(e,t=0){if(null===this._worldTransformPtr)throw new Error("Cannot set dynamic transform of non-dynamic body");this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setDynamicTransformMatrixFromArray(this._worldTransformPtr,e,t)}get needToCommit(){return this.impl.needToCommit??!1}commitToWasm(){if(void 0===this.impl.commitToWasm)throw new Error("commit only avalible on buffered evaluation mode");this._nullCheck(),this.runtime.lock.wait(),this.impl.commitToWasm(this._motionStatePtr,this._temporalKinematicStatePtr,this._worldTransformPtr)}}},67647:(e,t,r)=>{r.r(t),r.d(t,{SceneBuilder:()=>g}),r(90203),r(33832),r(2093);var n=r(7839),i=r(52046),s=r(71513),a=r(18595),o=r(26041),c=r(79923),h=r(96793),d=r(58144),m=r(87491),l=r(46738),f=r(67168),w=r(25203),u=r(29009),p=r(47002),_=r(26405),y=r(1592),R=r(35901);class g{async build(e,t){const r=new m.Z(t);r.clearColor=new o.ov(.95,.95,.95,1);const g=new n.L("arcRotateCamera",0,0,500,new c.Pq(0,0,0),r);g.minZ=1,g.maxZ=1e3,g.setPosition(new c.Pq(10,10,-5)),g.attachControl(void 0,!1),g.inertia=.8,g.speed=10;const T=new s.g("hemisphericLight",new c.Pq(0,1,0),r);T.intensity=.5,T.specular=new o.v9(0,0,0),T.groundColor=new o.v9(1,1,1);const S=new i.Z("directionalLight",new c.Pq(.5,-1,1),r);S.intensity=.5;S.shadowMaxZ=60,S.shadowMinZ=-60,S.autoCalcShadowZBounds=!1,S.autoUpdateExtends=!1,S.shadowOrthoScale=0,S.orthoTop=60,S.orthoBottom=-60,S.orthoLeft=-60,S.orthoRight=60;const C=new a.o(2048,S,!0);C.transparencyShadow=!0,C.usePercentageCloserFiltering=!0,C.forceBackFacesOnly=!1,C.bias=.004,C.filteringQuality=a.o.QUALITY_MEDIUM;const A=await(0,l.e)(new p.t,1),P=new w.w(A);P.register(r),P.evaluationType=u.q.Immediate;const b=new c.uq;{const e=(0,d.x)("ground",{size:120},r);e.rotationQuaternion=c.PT.RotationAxis(new c.Pq(1,0,0),Math.PI/2),C.addShadowCaster(e),e.receiveShadows=!0;const t=new _.Ty(P,new c.Pq(0,0,-1),0),n=new R.t(A);n.shape=t,c.uq.FromQuaternionToRef(e.rotationQuaternion,b),n.setInitialTransform(b),n.motionType=1;const i=new y.U(P,n);P.addRigidBody(i)}const L=new _.SA(P,new c.Pq(1,1,1)),I=new R.t(A);I.motionType=0,I.shape=L,I.setInitialTransform(c.uq.TranslationToRef(0,3,0,b)),I.friction=1,I.linearDamping=.3,I.angularDamping=.3,I.disableDeactivation=!0;const M=(0,h.an)("box1",{size:2},r);C.addShadowCaster(M),M.receiveShadows=!0,M.rotationQuaternion=c.PT.Identity();const v=new y.U(P,I);P.addRigidBody(v);const k=(0,h.an)("box2",{size:2},r);C.addShadowCaster(k),k.receiveShadows=!0,k.position.set(0,6,0),k.rotationQuaternion=c.PT.Identity();const x=new y.U(P,I);P.addRigidBody(x);const B=new f.o6(P,v,x,c.uq.Translation(0,1,0),c.uq.Translation(0,-1,0),!0);B.setLinearLowerLimit(new c.Pq(0,0,0)),B.setLinearUpperLimit(new c.Pq(0,0,0)),B.setAngularLowerLimit(new c.Pq(Math.PI/4,0,0)),B.setAngularUpperLimit(new c.Pq(0,0,0)),P.addConstraint(B,!0);let F=0,U=0;return P.onTickObservable.add((()=>{v.getTransformMatrixToRef(b),b.getTranslationToRef(M.position),c.PT.FromRotationMatrixToRef(b,M.rotationQuaternion),x.getTransformMatrixToRef(b),b.getTranslationToRef(k.position),c.PT.FromRotationMatrixToRef(b,k.rotationQuaternion),F+=t.getDeltaTime(),U+=1,U%3==0&&(b.setTranslationFromFloats(0,3*Math.sin(F/1e3),0),v.setTransformMatrix(b))})),window.runtime=P,window.body1=v,r}}}}]);