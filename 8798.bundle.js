"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[8798],{67168:(e,t,r)=>{r.d(t,{vC:()=>a});class n{_wasmInstance;_ptr;_bodyReference;_referenceCount;constructor(e,t,r){this._wasmInstance=e,this._ptr=t,this._bodyReference=r,Array.isArray(r)?(r[0].addReference(),r[1].addReference()):r.addReference(),this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose constraint while it still has references");0!==this._ptr&&(this._wasmInstance.deref()?.destroyConstraint(this._ptr),this._ptr=0,Array.isArray(this._bodyReference)?(this._bodyReference[0].removeReference(),this._bodyReference[1].removeReference()):this._bodyReference.removeReference(),this._bodyReference=null)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}}function i(e){e.dispose()}const s=new WeakMap;class o{runtime;_inner;_worldReference;constructor(e,t,r){if(Array.isArray(r)){if(r[0].runtime!==e||r[1].runtime!==e)throw new Error("Cannot create constraint between bodies from different runtimes")}else if(r.runtime!==e)throw new Error("Cannot create constraint between body and bundle from different runtimes");this.runtime=e,this._inner=new n(new WeakRef(e.wasmInstance),t,r),this._worldReference=null;let o=s.get(e.wasmInstance);void 0===o&&(o=new FinalizationRegistry(i),s.set(e.wasmInstance,o)),o.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add constraint to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}}class a extends o{constructor(e,t,r,n,i,s){const o=e.wasmInstance,a=o.allocateBuffer(64),c=o.createTypedArray(Float32Array,a,16);n.copyToArray(c.array);const h=o.allocateBuffer(64),d=o.createTypedArray(Float32Array,h,16);i.copyToArray(d.array);const f=Array.isArray(r),l=f?o.createGeneric6DofSpringConstraintFromBundle(t.ptr,r[0],r[1],a,h,s):o.createGeneric6DofSpringConstraint(t.ptr,r.ptr,a,h,s);o.deallocateBuffer(a,64),o.deallocateBuffer(h,64),super(e,l,f?t:[t,r])}setLinearLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setLinearUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearUpperLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularUpperLimit(this._inner.ptr,e.x,e.y,e.z)}enableSpring(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintEnableSpring(this._inner.ptr,e,t)}setStiffness(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetStiffness(this._inner.ptr,e,t)}setDamping(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetDamping(this._inner.ptr,e,t)}}},1592:(e,t,r)=>{r.d(t,{U:()=>o});class n{_wasmInstance;_ptr;_shapeReference;_referenceCount;_shadowCount;constructor(e,t,r){this._wasmInstance=e,this._ptr=t,this._shapeReference=r,r.addReference(),this._referenceCount=0,this._shadowCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose rigid body while it still has references");if(this._shadowCount>0)throw new Error("Cannot dispose rigid body while it still has shadows");0!==this._ptr&&(this._wasmInstance.deref()?.destroyRigidBody(this._ptr),this._ptr=0,this._shapeReference.removeReference(),this._shapeReference=null)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}addShadow(){this._shadowCount+=1}removeShadow(){this._shadowCount-=1}get hasShadows(){return 0<this._shadowCount}}function i(e){e.dispose()}const s=new WeakMap;class o{runtime;_motionStatePtr;_bufferedMotionStatePtr;_inner;_worldReference;impl;isDynamic;constructor(e,t,r){const o=void 0!==r?t.getPtr(r):t.ptr;if(0===o)throw new Error("Cannot create rigid body with null pointer");let a;if(a=void 0!==r?t.getShape(r):t.shape,null===a)throw new Error("Cannot create rigid body with null shape");if(a.runtime!==e)throw new Error("Cannot create rigid body with shapes from different runtimes");this.runtime=e;const c=e.wasmInstance,h=c.createRigidBody(o),d=c.rigidBodyGetMotionStatePtr(h);this._motionStatePtr=c.createTypedArray(Float32Array,d,20);const f=c.rigidBodyGetBufferedMotionStatePtr(h);this._bufferedMotionStatePtr=c.createTypedArray(Float32Array,f,20),this._inner=new n(new WeakRef(e.wasmInstance),h,a),this._worldReference=null;let l=s.get(c);void 0===l&&(l=new FinalizationRegistry(i),s.set(c,l)),l.register(this,this._inner,this),this.impl=e.createRigidBodyImpl(),this.isDynamic=void 0!==r?0===t.getMotionType(r):0===t.motionType}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}addShadowReference(){this._inner.addShadow()}removeShadowReference(){this._inner.removeShadow()}get hasShadows(){return this._inner.hasShadows}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add rigid body to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==this._worldReference?this._inner.addReference():this._inner.removeReference())}getWorldReference(){return this._worldReference}updateBufferedMotionState(e){if(this._nullCheck(),e){const e=this.runtime.wasmInstance.rigidBodyGetMotionStatePtr(this._inner.ptr);this._bufferedMotionStatePtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20)}else{const e=this.runtime.wasmInstance.rigidBodyGetBufferedMotionStatePtr(this._inner.ptr);this._bufferedMotionStatePtr=this.runtime.wasmInstance.createTypedArray(Float32Array,e,20)}}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed rigid body")}makeKinematic(){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyMakeKinematic(this._inner.ptr)}restoreDynamic(){this._nullCheck(),this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.rigidBodyRestoreDynamic(this._inner.ptr)}getTransformMatrixToRef(e){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const t=this._bufferedMotionStatePtr.array;return e.set(t[4],t[8],t[12],0,t[5],t[9],t[13],0,t[6],t[10],t[14],0,t[16],t[17],t[18],1)}getTransformMatrixToArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait();const r=this._bufferedMotionStatePtr.array;e[t+0]=r[4],e[t+1]=r[8],e[t+2]=r[12],e[t+3]=0,e[t+4]=r[5],e[t+5]=r[9],e[t+6]=r[13],e[t+7]=0,e[t+8]=r[6],e[t+9]=r[10],e[t+10]=r[14],e[t+11]=0,e[t+12]=r[16],e[t+13]=r[17],e[t+14]=r[18],e[t+15]=1}setTransformMatrix(e){this.setTransformMatrixFromArray(e.m,0)}setTransformMatrixFromArray(e,t=0){this._nullCheck(),this._inner.hasReferences&&this.impl.shouldSync&&this.runtime.lock.wait(),this.impl.setTransformMatrixFromArray(this._motionStatePtr,e,t)}}},8798:(e,t,r)=>{r.r(t),r.d(t,{SceneBuilder:()=>C}),r(90203),r(33832),r(2093);var n=r(7839),i=r(52046),s=r(71513),o=r(18595),a=r(26041),c=r(79923),h=r(96793),d=r(58144),f=r(87491),l=r(46738),u=r(67168),w=r(2090),m=r(27744),p=r(91167),_=r(15733),y=r(26405),R=r(1592),g=r(35901),S=r(89800);class C{async build(e,t){const r=new f.Z(t);r.clearColor=new a.ov(.95,.95,.95,1);const C=new n.L("arcRotateCamera",0,0,500,new c.Pq(0,0,0),r);C.minZ=1,C.maxZ=3e3,C.setPosition(new c.Pq(60,40,-50).scaleInPlace(10)),C.attachControl(void 0,!1),C.inertia=.8,C.speed=10;const b=new s.g("hemisphericLight",new c.Pq(0,1,0),r);b.intensity=.5,b.specular=new a.v9(0,0,0),b.groundColor=new a.v9(1,1,1);const I=new i.Z("directionalLight",new c.Pq(.5,-1,1),r);I.intensity=.5;I.shadowMaxZ=250,I.shadowMinZ=-250,I.autoCalcShadowZBounds=!1,I.autoUpdateExtends=!1,I.shadowOrthoScale=0,I.orthoTop=250,I.orthoBottom=-250,I.orthoLeft=-250,I.orthoRight=250;const A=new o.o(2048,I,!0);A.transparencyShadow=!0,A.usePercentageCloserFiltering=!0,A.forceBackFacesOnly=!1,A.bias=.004,A.filteringQuality=o.o.QUALITY_MEDIUM;const T=parseInt(prompt("Thread count","2"));console.log("Thread count:",T);const P=1===T?await(0,l.e)(new p.Z):await(0,l.e)(new m.t,T),k=new w.D(P),v=new _.F(k,!0),L=new c.uq;{const e=(0,d.x)("ground",{size:500},r);e.rotationQuaternion=c.PT.RotationAxis(new c.Pq(1,0,0),Math.PI/2),A.addShadowCaster(e),e.receiveShadows=!0;const t=new y.Ty(k,new c.Pq(0,0,-1),0),n=new g.t(P);n.shape=t,c.uq.FromQuaternionToRef(e.rotationQuaternion,L),n.setInitialTransform(L),n.motionType=1;const i=new R.U(k,n);v.addRigidBodyToGlobal(i)}const M=512,B=(0,h.an)("box",{size:2},r);A.addShadowCaster(B),B.receiveShadows=!0;const x=new Float32Array(262144);B.thinInstanceSetBuffer("matrix",x,16,!1);const F=new y.SA(k,new c.Pq(1,1,1)),q=[];for(let e=0;e<4;++e)for(let t=0;t<8;++t){const r=8*e+t,n=60*(t-4)+30,i=60*(e-2)+30,s=[];for(let e=0;e<M;++e){const t=new g.t(P);t.shape=F;const r=c.uq.TranslationToRef(n,1+2*e,i,L);t.setInitialTransform(r),t.friction=1,t.linearDamping=.3,t.angularDamping=.3,s.push(t)}for(let e=0;e<M;++e){const t=s[e],n=new R.U(k,t);v.addRigidBody(n,r),q.push(n)}for(let e=0;e<M;e+=2){const t=[r*M+e,r*M+e+1],n=new u.vC(k,q[t[0]],q[t[1]],c.uq.Translation(0,-1.2,0),c.uq.Translation(0,1.2,0),!0);n.setLinearLowerLimit(new c.Pq(0,0,0)),n.setLinearUpperLimit(new c.Pq(0,0,0)),n.setAngularLowerLimit(new c.Pq(Math.PI/4,0,0)),n.setAngularUpperLimit(new c.Pq(0,0,0));for(let e=0;e<6;++e)n.enableSpring(e,!0),n.setStiffness(e,100),n.setDamping(e,1);v.addConstraint(n,r,!0)}}return console.log("Rigid body count:",16384),new S.X((()=>{const e=performance.now();v.stepSimulation(1/60,10,1/60);for(let e=0;e<q.length;++e){const t=16*e;q[e].getTransformMatrixToRef(L),L.copyToArray(x,t)}B.thinInstanceBufferUpdated("matrix");const t=performance.now(),n=t-e;return r.render(),[n,performance.now()-t]})).runBench(),r.onBeforeRenderObservable.add((()=>{v.stepSimulation(1/60,10,1/60);for(let e=0;e<q.length;++e)q[e].getTransformMatrixToArray(x,16*e);B.thinInstanceBufferUpdated("matrix")})),r}}}}]);