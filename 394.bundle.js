"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[394],{394:(e,t,o)=>{o.r(t),o.d(t,{SceneBuilder:()=>B}),o(203),o(1503),o(8227),o(3108);var n=o(7456),r=o(5581),i=o(1513),s=o(9711),a=o(6041),l=o(9923),d=o(8144),h=o(3490),m=o(8014),p=o(825),w=o(554),c=o(6738),u=o(7002),M=o(1137),g=o(9848),f=o(5431),T=o(3948),E=o(1592);class y extends E.U{}var I=o(7648);class D extends I.Y{info;constructor(e,t){super(e,t),this.info=t}setDamping(e,t,o){super.setDamping(e,t,o),this.info.setLinearDamping(e,t),this.info.setAngularDamping(e,o)}setMassProps(e,t,o){super.setMassProps(e,t,o),this.info.setMass(e,t),this.info.setLocalInertia(e,o)}get length(){return this.count}}var b=o(5901);class x extends b.t{worldId;constructor(e){super(e),this.worldId=0}}var A=o(3477);class C extends A.x{worldId;constructor(e,t){super(e,t),this.worldId=0}get length(){return this.count}}var _=o(6405);const v=new l.Pq;class S extends _.SA{localTransform;collisionGroup=1;collisionMask=65535;_material=null;constructor(e,t,o,n){super(e,n?.scaleToRef(.5,v)??v.setAll(.5)),this.localTransform=function(e,t,o){return!1===e?.equalsToFloats(0,0,0)||!1===t?.equalsToFloats(0,0,0,1)?(void 0!==t?(void 0===o&&(o=new l.uq),o=l.uq.FromQuaternionToRef(t,o),void 0!==e&&o.setTranslation(e)):void 0!==e?(void 0===o?o=l.uq.Identity():l.uq.IdentityToRef(o),o.setTranslation(e)):void 0===o?o=l.uq.Identity():l.uq.IdentityToRef(o),o):null}(t,o)}setMaterial(e,t){this._material={friction:e,restitution:t}}get material(){return this._material}}class P{worldId;constructor(){this.worldId=0}}class L{world;name="BulletPlugin";onCollisionObservable=new g.cP;onCollisionEndedObservable=new g.cP;onTriggerCollisionObservable=new g.cP;_initializedBodies=[];_unInitializedBodies=[];commandContext=new P;constructor(e){this.world=new T.h(e)}setGravity(e){this.world.setGravity(e)}setTimeStep(e){this.world.timeStep=e}getTimeStep(){return this.world.timeStep}executeStep(e,t){{const e=this._unInitializedBodies;for(let t=0;t<e.length;++t){const o=e[t],n=o._pluginData;if(n){if(!(n instanceof x))throw new Error("Invalid body type.");{const r=new y(this.world,n);this.world.addRigidBody(r,n.worldId),this._initializedBodies.push(e[t]),o._pluginData=r}}const r=o._pluginDataInstances;if(r){if(!(r instanceof C))throw new Error("Invalid body type.");{const n=new D(this.world,r);this.world.addRigidBodyBundle(n,r.worldId),this._initializedBodies.push(e[t]),o._pluginDataInstances=n}}}e.length=0}for(let e=0;e<t.length;++e){const o=t[e];o.disablePreStep||this.setPhysicsBodyTransformation(o,o.transformNode)}this.world.afterAnimations(e);for(let e=0;e<t.length;++e){const o=t[e];o.disableSync||this.sync(o)}}setPhysicsBodyTransformation(e,t){if(e.getPrestepType()===h.f9.TELEPORT){const o=e.transformNode,n=e._pluginData;n&&(n instanceof y?n.setTransformMatrix(this._getTransformInfos(t,L._TempMatrix)):n instanceof x&&n.setInitialTransform(this._getTransformInfos(t,L._TempMatrix)));const r=e._pluginDataInstances;if(r){const e=o._thinInstanceDataStorage.matrixData;if(!e)return;if(r instanceof D)r.setTransformMatricesFromArray(e);else if(r instanceof C)for(let t=0;t<r.count;++t){const o=l.uq.FromArrayToRef(e,16*t,L._TempMatrix);r.setInitialTransform(t,o)}}}else e.getPrestepType()===h.f9.ACTION?this.setTargetTransform(e,t.absolutePosition,t.absoluteRotationQuaternion):e.getPrestepType()===h.f9.DISABLED?M.V.Warn("Prestep type is set to DISABLED. Unable to set physics body transformation."):M.V.Warn("Invalid prestep type set to physics body.")}getPluginVersion(){return 2}setVelocityLimits(e,t){throw new Error("Method not implemented.")}getMaxLinearVelocity(){throw new Error("Method not implemented.")}getMaxAngularVelocity(){throw new Error("Method not implemented.")}static _MotionTypeToBullet(e){switch(e){case h.AH.DYNAMIC:return 0;case h.AH.STATIC:return 1;case h.AH.ANIMATED:return 2;default:throw new Error("Invalid motion type")}}static _TempMatrix=new l.uq;initBody(e,t,o,n){const r=e._pluginData=new x(this.world.wasmInstance);r.motionType=L._MotionTypeToBullet(t);const i=l.uq.FromQuaternionToRef(n,L._TempMatrix);i.setTranslation(o),r.setInitialTransform(i),this._unInitializedBodies.push(e)}initBodyInstances(e,t,o){const n=o._thinInstanceDataStorage?.instancesCount??0,r=o._thinInstanceDataStorage.matrixData;if(!r)return;const i=new C(this.world.wasmInstance,n);e._pluginDataInstances=i;const s=L._MotionTypeToBullet(t);for(let e=0;e<n;++e){i.setMotionType(e,s);const t=l.uq.FromArrayToRef(r,16*e,L._TempMatrix);i.setInitialTransform(e,t)}this._unInitializedBodies.push(e)}updateBodyInstances(e,t){const o=t._thinInstanceDataStorage?.instancesCount??0,n=t._thinInstanceDataStorage.matrixData;if(!n)return;const r=e._pluginDataInstances,i=r.length,s=L._MotionTypeToBullet(this.getMotionType(e));if(o!==i&&r instanceof D){this.world.removeRigidBodyBundle(r,r.info.worldId);const e=r.info,t=new C(this.world.wasmInstance,o);{const n=Math.min(o,i);for(let o=0;o<n;++o)t.setShape(o,e.getShape(o)),t.setInitialTransform(o,r.getTransformMatrixToRef(o,L._TempMatrix)),t.setMotionType(o,e.getMotionType(o)),t.setMass(o,e.getMass(o)),t.setLocalInertia(o,e.getLocalInertiaToRef(o,l.AA.Vector3[0])),t.setLinearDamping(o,e.getLinearDamping(o)),t.setAngularDamping(o,e.getAngularDamping(o)),t.setFriction(o,e.getFriction(o)),t.setRestitution(o,e.getRestitution(o)),t.setLinearSleepingThreshold(o,e.getLinearSleepingThreshold(o)),t.setAngularSleepingThreshold(o,e.getAngularSleepingThreshold(o)),t.setCollisionGroup(o,e.getCollisionGroup(o)),t.setCollisionMask(o,e.getCollisionMask(o)),t.setAdditionalDamping(o,e.getAdditionalDamping(o)),t.setNoContactResponse(o,e.getNoContactResponse(o)),t.setDisableDeactivation(o,e.getDisableDeactivation(o))}for(let e=i;e<o;++e)t.setInitialTransform(e,l.uq.FromArrayToRef(n,16*e,L._TempMatrix)),t.setMotionType(e,s);const a=new D(this.world,t);this.world.addRigidBodyBundle(a,t.worldId)}}removeBody(e){throw new Error("Method not implemented.")}sync(e){throw new Error("Method not implemented.")}syncTransform(e,t){throw new Error("Method not implemented.")}setShape(e,t){throw new Error("Method not implemented.")}getShape(e){throw new Error("Method not implemented.")}getShapeType(e){throw new Error("Method not implemented.")}setEventMask(e,t,o){throw new Error("Method not implemented.")}getEventMask(e,t){throw new Error("Method not implemented.")}setMotionType(e,t,o){throw new Error("Method not implemented.")}getMotionType(e,t){throw new Error("Method not implemented.")}computeMassProperties(e,t){throw new Error("Method not implemented.")}setMassProperties(e,t,o){const n=e._pluginData;if(void 0!==t.inertiaOrientation&&M.V.Warn("Inertia orientation is not supported in bullet."),void 0!==t.centerOfMass&&M.V.Warn("Center of mass is not supported in bullet."),n instanceof x)void 0!==t.mass&&(n.mass=t.mass),void 0!==t.inertia&&(n.localInertia=t.inertia);else{if(!(n instanceof C))throw new Error("mass cannot be set after body is initialized");{const e=o??0,r=void 0!==o?o+1:n.count;for(let o=e;o<r;++o)void 0!==t.mass&&n.setMass(o,t.mass),void 0!==t.inertia&&n.setLocalInertia(o,t.inertia)}}}getMassProperties(e,t){throw new Error("Method not implemented.")}setLinearDamping(e,t,o){throw new Error("Method not implemented.")}getLinearDamping(e,t){throw new Error("Method not implemented.")}setAngularDamping(e,t,o){throw new Error("Method not implemented.")}getAngularDamping(e,t){throw new Error("Method not implemented.")}setLinearVelocity(e,t,o){throw new Error("Method not implemented.")}getLinearVelocityToRef(e,t,o){throw new Error("Method not implemented.")}applyImpulse(e,t,o,n){throw new Error("Method not implemented.")}applyAngularImpulse(e,t,o){throw new Error("Method not implemented.")}applyForce(e,t,o,n){throw new Error("Method not implemented.")}setAngularVelocity(e,t,o){throw new Error("Method not implemented.")}getAngularVelocityToRef(e,t,o){throw new Error("Method not implemented.")}getBodyGeometry(e){throw new Error("Method not implemented.")}disposeBody(e){throw new Error("Method not implemented.")}setCollisionCallbackEnabled(e,t,o){throw new Error("Method not implemented.")}setCollisionEndedCallbackEnabled(e,t,o){throw new Error("Method not implemented.")}addConstraint(e,t,o,n,r){throw new Error("Method not implemented.")}getCollisionObservable(e,t){throw new Error("Method not implemented.")}getCollisionEndedObservable(e,t){throw new Error("Method not implemented.")}setGravityFactor(e,t,o){throw new Error("Method not implemented.")}getGravityFactor(e,t){throw new Error("Method not implemented.")}setTargetTransform(e,t,o,n){const r=l.uq.FromQuaternionToRef(o,L._TempMatrix);r.setTranslation(t);const i=e._pluginData;i&&(i instanceof x?i.setInitialTransform(r):i instanceof y&&i.setDynamicTransformMatrix(r,!0));const s=e._pluginDataInstances;if(s){const e=n??0,t=void 0!==n?n+1:s.length;if(s instanceof C)for(let o=e;o<t;++o)s.setInitialTransform(o,r);else if(s instanceof D)for(let o=e;o<t;++o)s.setDynamicTransformMatrix(o,r,!0)}}initShape(e,t,o){switch(t){case h.DK.SPHERE:throw new Error("Sphere shape not supported.");case h.DK.BOX:e._pluginData=new S(this.world,o.center,o.rotation,o.extents);break;case h.DK.CAPSULE:throw new Error("Capsule shape not supported.");case h.DK.CONTAINER:throw new Error("Container shape not supported.");case h.DK.CYLINDER:throw new Error("Cylinder shape not supported.");case h.DK.CONVEX_HULL:case h.DK.MESH:throw new Error("Convex hull and mesh shapes not supported.");case h.DK.HEIGHTFIELD:throw new Error("Heightfield shape not supported.");default:throw new Error("Unsupported Shape Type.")}}setShapeFilterMembershipMask(e,t){e._pluginData.collisionGroup=t}getShapeFilterMembershipMask(e){return e._pluginData.collisionGroup}setShapeFilterCollideMask(e,t){e._pluginData.collisionMask=t}getShapeFilterCollideMask(e){return e._pluginData.collisionMask}setMaterial(e,t){const o=t.friction??.5;t.staticFriction&&M.V.Warn("Static friction is not supported in bullet.");const n=t.restitution??0;t.frictionCombine&&t.frictionCombine!==f.F.MULTIPLY&&M.V.Warn("Friction combine is fixed to MULTIPLY in bullet."),t.restitutionCombine&&t.restitutionCombine!==f.F.MULTIPLY&&M.V.Warn("Restitution combine is fixed to MULTIPLY in bullet."),e._pluginData.setMaterial(o,n)}getMaterial(e){throw new Error("Method not implemented.")}setDensity(e,t){throw new Error("Method not implemented.")}getDensity(e){throw new Error("Method not implemented.")}_getTransformInfos(e,t){if(e.parent){const o=e.computeWorldMatrix(!0);return t.copyFrom(o)}let o=l.AA.Quaternion[0];if(e.rotationQuaternion)o=e.rotationQuaternion;else{const t=e.rotation;l.PT.FromEulerAnglesToRef(t.x,t.y,t.z,o)}return l.uq.FromQuaternionToRef(o,t),t.setTranslation(e.position),t}addChild(e,t,o,n,r){throw new Error("Method not implemented.")}removeChild(e,t){throw new Error("Method not implemented.")}getNumChildren(e){throw new Error("Method not implemented.")}getBoundingBox(e){throw new Error("Method not implemented.")}getBodyBoundingBox(e){throw new Error("Method not implemented.")}disposeShape(e){throw new Error("Method not implemented.")}setTrigger(e,t){throw new Error("Method not implemented.")}initConstraint(e,t,o){throw new Error("Method not implemented.")}setEnabled(e,t){throw new Error("Method not implemented.")}getEnabled(e){throw new Error("Method not implemented.")}setCollisionsEnabled(e,t){throw new Error("Method not implemented.")}getCollisionsEnabled(e){throw new Error("Method not implemented.")}setAxisFriction(e,t,o){throw new Error("Method not implemented.")}getAxisFriction(e,t){throw new Error("Method not implemented.")}setAxisMode(e,t,o){throw new Error("Method not implemented.")}getAxisMode(e,t){throw new Error("Method not implemented.")}setAxisMinLimit(e,t,o){throw new Error("Method not implemented.")}getAxisMinLimit(e,t){throw new Error("Method not implemented.")}setAxisMaxLimit(e,t,o){throw new Error("Method not implemented.")}getAxisMaxLimit(e,t){throw new Error("Method not implemented.")}setAxisMotorType(e,t,o){throw new Error("Method not implemented.")}getAxisMotorType(e,t){throw new Error("Method not implemented.")}setAxisMotorTarget(e,t,o){throw new Error("Method not implemented.")}getAxisMotorTarget(e,t){throw new Error("Method not implemented.")}setAxisMotorMaxForce(e,t,o){throw new Error("Method not implemented.")}getAxisMotorMaxForce(e,t){throw new Error("Method not implemented.")}disposeConstraint(e){throw new Error("Method not implemented.")}getBodiesUsingConstraint(e){throw new Error("Method not implemented.")}raycast(e,t,o,n){throw new Error("Method not implemented.")}dispose(){throw new Error("Method not implemented.")}}class B{async build(e,t){const o=new w.Z(t);o.clearColor=new a.ov(.95,.95,.95,1);const M=new n.Lq("arcRotateCamera",0,0,500,new l.Pq(0,0,0),o);M.minZ=1,M.maxZ=1e3,M.setPosition(new l.Pq(60,40,-50)),M.attachControl(void 0,!1),M.inertia=.8,M.speed=10;const g=new i.g("hemisphericLight",new l.Pq(0,1,0),o);g.intensity=.5,g.specular=new a.v9(0,0,0),g.groundColor=new a.v9(1,1,1);const f=new r.Z("directionalLight",new l.Pq(.5,-1,1),o);f.intensity=.5;f.shadowMaxZ=60,f.shadowMinZ=-60,f.autoCalcShadowZBounds=!1,f.autoUpdateExtends=!1,f.shadowOrthoScale=0,f.orthoTop=60,f.orthoBottom=-60,f.orthoLeft=-60,f.orthoRight=60;const T=new s.o(2048,f,!0);T.transparencyShadow=!0,T.usePercentageCloserFiltering=!0,T.forceBackFacesOnly=!1,T.bias=.004,T.filteringQuality=s.o.QUALITY_MEDIUM;const E=await(0,c.e)(new u.t,2);o.enablePhysics(new l.Pq(0,-9.8,0),new L(E));{const e=(0,d.x)("ground",{size:120},o);e.rotationQuaternion=l.PT.RotationAxis(new l.Pq(1,0,0),Math.PI/2),T.addShadowCaster(e),e.receiveShadows=!0;const t=new p.cL(new l.Pq(0,0,-100),l.PT.Identity(),new l.Pq(1e3,1e3,200),o);t.material={friction:10,restitution:.5},t.filterCollideMask=65535,t.filterMembershipMask=1;const n=new m.a(e,h.AH.STATIC,!1,o);n.setMassProperties({mass:0}),n.setLinearDamping(.3),n.setAngularDamping(.3),n.computeMassProperties()}return o}}}}]);