"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[6560],{54179:(e,t,o)=>{o.r(t),o.d(t,{SceneBuilder:()=>x}),o(90203),o(33832),o(2093),o(42163);var r=o(7839),n=o(52046),i=o(71513),s=o(18595),a=o(26041),l=o(79923),d=o(58144),h=o(73490),m=o(8014),w=o(825),p=o(87491),c=o(46738),M=o(47002),E=o(51137),u=o(99848),g=o(55431),y=o(23948),T=o(35901),b=o(3477),f=o(26405);const C=new l.Pq;class A extends f.SA{localTransform;collisionGroup=1;collisionMask=65535;_material=null;constructor(e,t,o,r){super(e,r?.scaleToRef(.5,C)??C.setAll(.5)),this.localTransform=function(e,t,o){return!1===e?.equalsToFloats(0,0,0)||!1===t?.equalsToFloats(0,0,0,1)?(void 0!==t?(void 0===o&&(o=new l.uq),o=l.uq.FromQuaternionToRef(t,o),void 0!==e&&o.setTranslation(e)):void 0!==e?(void 0===o?o=l.uq.Identity():l.uq.IdentityToRef(o),o.setTranslation(e)):void 0===o?o=l.uq.Identity():l.uq.IdentityToRef(o),o):null}(t,o)}setMaterial(e,t){this._material={friction:e,restitution:t}}get material(){return this._material}}class P{world;name="BulletPlugin";onCollisionObservable=new u.cP;onCollisionEndedObservable=new u.cP;onTriggerCollisionObservable=new u.cP;constructor(e){this.world=new y.h(e)}setGravity(e){this.world.setGravity(e)}setTimeStep(e){this.world.timeStep=e}getTimeStep(){return this.world.timeStep}executeStep(e,t){for(let e=0;e<t.length;++e){const o=t[e];o.disablePreStep||this.setPhysicsBodyTransformation(o,o.transformNode)}this.world.afterAnimations(e);for(let e=0;e<t.length;++e){const o=t[e];o.disableSync||this.sync(o)}}setPhysicsBodyTransformation(e,t){if(e.getPrestepType()==h.f9.TELEPORT){const t=e.transformNode;if(e.numInstances>0&&!t._thinInstanceDataStorage.matrixData)return}else e.getPrestepType()==h.f9.ACTION?this.setTargetTransform(e,t.absolutePosition,t.absoluteRotationQuaternion):e.getPrestepType()==h.f9.DISABLED?E.V.Warn("Prestep type is set to DISABLED. Unable to set physics body transformation."):E.V.Warn("Invalid prestep type set to physics body.")}getPluginVersion(){return 2}setVelocityLimits(e,t){throw new Error("Method not implemented.")}getMaxLinearVelocity(){throw new Error("Method not implemented.")}getMaxAngularVelocity(){throw new Error("Method not implemented.")}static _TempMatrix=new l.uq;initBody(e,t,o,r){const n=e._pluginData=new T.t(this.world.wasmInstance);let i;switch(t){case h.AH.DYNAMIC:i=0;break;case h.AH.STATIC:i=1;break;case h.AH.ANIMATED:i=2;break;default:throw new Error("Invalid motion type")}n.motionType=i;const s=l.uq.FromQuaternionToRef(r,P._TempMatrix);s.setTranslation(o),n.setInitialTransform(s)}initBodyInstances(e,t,o){throw new Error("Method not implemented.")}updateBodyInstances(e,t){throw new Error("Method not implemented.")}removeBody(e){throw new Error("Method not implemented.")}sync(e){throw new Error("Method not implemented.")}syncTransform(e,t){throw new Error("Method not implemented.")}setShape(e,t){throw new Error("Method not implemented.")}getShape(e){throw new Error("Method not implemented.")}getShapeType(e){throw new Error("Method not implemented.")}setEventMask(e,t,o){throw new Error("Method not implemented.")}getEventMask(e,t){throw new Error("Method not implemented.")}setMotionType(e,t,o){throw new Error("Method not implemented.")}getMotionType(e,t){throw new Error("Method not implemented.")}computeMassProperties(e,t){throw new Error("Method not implemented.")}setMassProperties(e,t,o){const r=e._pluginData;if(void 0!==t.inertiaOrientation&&E.V.Warn("Inertia orientation is not supported in bullet."),void 0!==t.centerOfMass&&E.V.Warn("Center of mass is not supported in bullet."),r instanceof T.t)void 0!==t.mass&&(r.mass=t.mass),void 0!==t.inertia&&(r.localInertia=t.inertia);else{if(!(r instanceof b.x))throw new Error("mass cannot be set after body is initialized");{const e=o??0,n=void 0!==o?o+1:r.count;for(let o=e;o<n;++o)void 0!==t.mass&&r.setMass(o,t.mass),void 0!==t.inertia&&r.setLocalInertia(o,t.inertia)}}}getMassProperties(e,t){throw new Error("Method not implemented.")}setLinearDamping(e,t,o){throw new Error("Method not implemented.")}getLinearDamping(e,t){throw new Error("Method not implemented.")}setAngularDamping(e,t,o){throw new Error("Method not implemented.")}getAngularDamping(e,t){throw new Error("Method not implemented.")}setLinearVelocity(e,t,o){throw new Error("Method not implemented.")}getLinearVelocityToRef(e,t,o){throw new Error("Method not implemented.")}applyImpulse(e,t,o,r){throw new Error("Method not implemented.")}applyAngularImpulse(e,t,o){throw new Error("Method not implemented.")}applyForce(e,t,o,r){throw new Error("Method not implemented.")}setAngularVelocity(e,t,o){throw new Error("Method not implemented.")}getAngularVelocityToRef(e,t,o){throw new Error("Method not implemented.")}getBodyGeometry(e){throw new Error("Method not implemented.")}disposeBody(e){throw new Error("Method not implemented.")}setCollisionCallbackEnabled(e,t,o){throw new Error("Method not implemented.")}setCollisionEndedCallbackEnabled(e,t,o){throw new Error("Method not implemented.")}addConstraint(e,t,o,r,n){throw new Error("Method not implemented.")}getCollisionObservable(e,t){throw new Error("Method not implemented.")}getCollisionEndedObservable(e,t){throw new Error("Method not implemented.")}setGravityFactor(e,t,o){throw new Error("Method not implemented.")}getGravityFactor(e,t){throw new Error("Method not implemented.")}setTargetTransform(e,t,o,r){throw new Error("Method not implemented.")}initShape(e,t,o){switch(t){case h.DK.SPHERE:throw new Error("Sphere shape not supported.");case h.DK.BOX:e._pluginData=new A(this.world,o.center,o.rotation,o.extents);break;case h.DK.CAPSULE:throw new Error("Capsule shape not supported.");case h.DK.CONTAINER:throw new Error("Container shape not supported.");case h.DK.CYLINDER:throw new Error("Cylinder shape not supported.");case h.DK.CONVEX_HULL:case h.DK.MESH:throw new Error("Convex hull and mesh shapes not supported.");case h.DK.HEIGHTFIELD:throw new Error("Heightfield shape not supported.");default:throw new Error("Unsupported Shape Type.")}}setShapeFilterMembershipMask(e,t){e._pluginData.collisionGroup=t}getShapeFilterMembershipMask(e){return e._pluginData.collisionGroup}setShapeFilterCollideMask(e,t){e._pluginData.collisionMask=t}getShapeFilterCollideMask(e){return e._pluginData.collisionMask}setMaterial(e,t){const o=t.friction??.5;t.staticFriction&&E.V.Warn("Static friction is not supported in bullet.");const r=t.restitution??0;t.frictionCombine&&t.frictionCombine!==g.F.MULTIPLY&&E.V.Warn("Friction combine is fixed to MULTIPLY in bullet."),t.restitutionCombine&&t.restitutionCombine!==g.F.MULTIPLY&&E.V.Warn("Restitution combine is fixed to MULTIPLY in bullet."),e._pluginData.setMaterial(o,r)}getMaterial(e){throw new Error("Method not implemented.")}setDensity(e,t){throw new Error("Method not implemented.")}getDensity(e){throw new Error("Method not implemented.")}addChild(e,t,o,r,n){throw new Error("Method not implemented.")}removeChild(e,t){throw new Error("Method not implemented.")}getNumChildren(e){throw new Error("Method not implemented.")}getBoundingBox(e){throw new Error("Method not implemented.")}getBodyBoundingBox(e){throw new Error("Method not implemented.")}disposeShape(e){throw new Error("Method not implemented.")}setTrigger(e,t){throw new Error("Method not implemented.")}initConstraint(e,t,o){throw new Error("Method not implemented.")}setEnabled(e,t){throw new Error("Method not implemented.")}getEnabled(e){throw new Error("Method not implemented.")}setCollisionsEnabled(e,t){throw new Error("Method not implemented.")}getCollisionsEnabled(e){throw new Error("Method not implemented.")}setAxisFriction(e,t,o){throw new Error("Method not implemented.")}getAxisFriction(e,t){throw new Error("Method not implemented.")}setAxisMode(e,t,o){throw new Error("Method not implemented.")}getAxisMode(e,t){throw new Error("Method not implemented.")}setAxisMinLimit(e,t,o){throw new Error("Method not implemented.")}getAxisMinLimit(e,t){throw new Error("Method not implemented.")}setAxisMaxLimit(e,t,o){throw new Error("Method not implemented.")}getAxisMaxLimit(e,t){throw new Error("Method not implemented.")}setAxisMotorType(e,t,o){throw new Error("Method not implemented.")}getAxisMotorType(e,t){throw new Error("Method not implemented.")}setAxisMotorTarget(e,t,o){throw new Error("Method not implemented.")}getAxisMotorTarget(e,t){throw new Error("Method not implemented.")}setAxisMotorMaxForce(e,t,o){throw new Error("Method not implemented.")}getAxisMotorMaxForce(e,t){throw new Error("Method not implemented.")}disposeConstraint(e){throw new Error("Method not implemented.")}getBodiesUsingConstraint(e){throw new Error("Method not implemented.")}raycast(e,t,o,r){throw new Error("Method not implemented.")}dispose(){throw new Error("Method not implemented.")}}class x{async build(e,t){const o=new p.Z(t);o.clearColor=new a.ov(.95,.95,.95,1);const E=new r.L("arcRotateCamera",0,0,500,new l.Pq(0,0,0),o);E.minZ=1,E.maxZ=1e3,E.setPosition(new l.Pq(60,40,-50)),E.attachControl(void 0,!1),E.inertia=.8,E.speed=10;const u=new i.g("hemisphericLight",new l.Pq(0,1,0),o);u.intensity=.5,u.specular=new a.v9(0,0,0),u.groundColor=new a.v9(1,1,1);const g=new n.Z("directionalLight",new l.Pq(.5,-1,1),o);g.intensity=.5;g.shadowMaxZ=60,g.shadowMinZ=-60,g.autoCalcShadowZBounds=!1,g.autoUpdateExtends=!1,g.shadowOrthoScale=0,g.orthoTop=60,g.orthoBottom=-60,g.orthoLeft=-60,g.orthoRight=60;const y=new s.o(2048,g,!0);y.transparencyShadow=!0,y.usePercentageCloserFiltering=!0,y.forceBackFacesOnly=!1,y.bias=.004,y.filteringQuality=s.o.QUALITY_MEDIUM;const T=await(0,c.e)(new M.t,2);o.enablePhysics(new l.Pq(0,-9.8,0),new P(T));{const e=(0,d.x)("ground",{size:120},o);e.rotationQuaternion=l.PT.RotationAxis(new l.Pq(1,0,0),Math.PI/2),y.addShadowCaster(e),e.receiveShadows=!0;const t=new w.cL(new l.Pq(0,0,-100),l.PT.Identity(),new l.Pq(1e3,1e3,200),o);t.material={friction:10,restitution:.5},t.filterCollideMask=65535,t.filterMembershipMask=1;const r=new m.a(e,h.AH.STATIC,!1,o);r.setMassProperties({mass:0}),r.setLinearDamping(.3),r.setAngularDamping(.3),r.computeMassProperties()}return o}}}}]);