"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[6560],{3477:(t,e,r)=>{r.d(e,{x:()=>s});class n{_wasmInstance;_ptr;_count;_shapeReferences;constructor(t,e,r){this._wasmInstance=t,this._ptr=e,this._count=r,this._shapeReferences=new Array(r).fill(null)}dispose(){if(0!==this._ptr){this._wasmInstance.deref()?.deallocateBuffer(this._ptr,128*this._count),this._ptr=0;for(let t=0;t<this._shapeReferences.length;++t){const e=this._shapeReferences[t];e?.removeReference()}this._shapeReferences.fill(null)}}get ptr(){return this._ptr}get count(){return this._count}getShape(t){return this._shapeReferences[t]??null}setShape(t,e){if(t<0||this._count<=t)throw new RangeError("Index out of range");const r=this._shapeReferences[t];r&&r.removeReference(),this._shapeReferences[t]=e,e&&e.addReference()}}function o(t){t.dispose()}const i=new WeakMap;class s{_wasmInstance;_uint32Ptr;_float32Ptr;_uint8Ptr;_uint16Ptr;_inner;constructor(t,e){this._wasmInstance=t;const r=t.allocateBuffer(128*e);this._uint32Ptr=t.createTypedArray(Uint32Array,r,32*e),this._float32Ptr=t.createTypedArray(Float32Array,r,32*e),this._uint8Ptr=t.createTypedArray(Uint8Array,r,128*e),this._uint16Ptr=t.createTypedArray(Uint16Array,r,64*e),this._inner=new n(new WeakRef(t),r,e);const s=this._uint32Ptr.array,a=this._float32Ptr.array,l=this._uint8Ptr.array,h=this._uint16Ptr.array;for(let t=0;t<e;++t){const e=128*t;s[(e+0)/4]=0,a[(e+16)/4+0]=1,a[(e+16)/4+1]=0,a[(e+16)/4+2]=0,a[(e+16)/4+3]=0,a[(e+16)/4+4]=0,a[(e+16)/4+5]=1,a[(e+16)/4+6]=0,a[(e+16)/4+7]=0,a[(e+16)/4+8]=0,a[(e+16)/4+9]=0,a[(e+16)/4+10]=1,a[(e+16)/4+11]=0,a[(e+16)/4+12]=0,a[(e+16)/4+13]=0,a[(e+16)/4+14]=0,a[(e+16)/4+15]=1,l[(e+80)/1]=0,a[(e+84)/4]=1,a[(e+88)/4]=0,a[(e+92)/4]=0,a[(e+96)/4]=.5,a[(e+100)/4]=0,a[(e+104)/4]=0,a[(e+108)/4]=1,h[(e+112)/2]=1,h[(e+114)/2]=65535,l[(e+116)/1]=0,l[(e+117)/1]=0,l[(e+118)/1]=0}let d=i.get(t);void 0===d&&(d=new FinalizationRegistry(o),i.set(t,d)),d.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const t=i.get(this._wasmInstance);t?.unregister(this)}get ptr(){return this._inner.ptr}get count(){return this._inner.count}getPtr(t){return this._nullCheck(),this._inner.ptr+128*t}_nullCheck(){if(0===this._inner.ptr)throw new Error("Cannot access disposed RigidBodyConstructionInfo")}getShape(t){return this._nullCheck(),this._inner.getShape(t)}setShape(t,e){this._nullCheck(),this._inner.setShape(t,e);const r=128*t;this._uint32Ptr.array[(r+0)/4]=e?e.ptr:0}getInitialTransformToRef(t,e){this._nullCheck();const r=128*t,n=this._float32Ptr.array;return e.set(n[(r+16)/4+0],n[(r+16)/4+1],n[(r+16)/4+2],n[(r+16)/4+3],n[(r+16)/4+4],n[(r+16)/4+5],n[(r+16)/4+6],n[(r+16)/4+7],n[(r+16)/4+8],n[(r+16)/4+9],n[(r+16)/4+10],n[(r+16)/4+11],n[(r+16)/4+12],n[(r+16)/4+13],n[(r+16)/4+14],n[(r+16)/4+15]),e}setInitialTransform(t,e){this._nullCheck();const r=128*t,n=this._float32Ptr.array;e.copyToArray(n,(r+16)/4)}getMotionType(t){this._nullCheck();const e=128*t;return this._uint8Ptr.array[(e+80)/1]}setMotionType(t,e){this._nullCheck();const r=128*t;this._uint8Ptr.array[(r+80)/1]=e}getMass(t){this._nullCheck();const e=128*t;return this._float32Ptr.array[(e+84)/4]}setMass(t,e){this._nullCheck();const r=128*t;this._float32Ptr.array[(r+84)/4]=e}getLinearDamping(t){this._nullCheck();const e=128*t;return this._float32Ptr.array[(e+88)/4]}setLinearDamping(t,e){this._nullCheck();const r=128*t;this._float32Ptr.array[(r+88)/4]=e}getAngularDamping(t){this._nullCheck();const e=128*t;return this._float32Ptr.array[(e+92)/4]}setAngularDamping(t,e){this._nullCheck();const r=128*t;this._float32Ptr.array[(r+92)/4]=e}getFriction(t){this._nullCheck();const e=128*t;return this._float32Ptr.array[(e+96)/4]}setFriction(t,e){this._nullCheck();const r=128*t;this._float32Ptr.array[(r+96)/4]=e}getRestitution(t){this._nullCheck();const e=128*t;return this._float32Ptr.array[(e+100)/4]}setRestitution(t,e){this._nullCheck();const r=128*t;this._float32Ptr.array[(r+100)/4]=e}getLinearSleepingThreshold(t){this._nullCheck();const e=128*t;return this._float32Ptr.array[(e+104)/4]}setLinearSleepingThreshold(t,e){this._nullCheck();const r=128*t;this._float32Ptr.array[(r+104)/4]=e}getAngularSleepingThreshold(t){this._nullCheck();const e=128*t;return this._float32Ptr.array[(e+108)/4]}setAngularSleepingThreshold(t,e){this._nullCheck();const r=128*t;this._float32Ptr.array[(r+108)/4]=e}getCollisionGroup(t){this._nullCheck();const e=128*t;return this._uint16Ptr.array[(e+112)/2]}setCollisionGroup(t,e){this._nullCheck();const r=128*t;this._uint16Ptr.array[(r+112)/2]=e}getCollisionMask(t){this._nullCheck();const e=128*t;return this._uint16Ptr.array[(e+114)/2]}setCollisionMask(t,e){this._nullCheck();const r=128*t;this._uint16Ptr.array[(r+114)/2]=e}getAdditionalDamping(t){this._nullCheck();const e=128*t;return!!this._uint8Ptr.array[(e+116)/1]}setAdditionalDamping(t,e){this._nullCheck();const r=128*t;this._uint8Ptr.array[(r+116)/1]=+e}getNoContactResponse(t){this._nullCheck();const e=128*t;return!!this._uint8Ptr.array[(e+117)/1]}setNoContactResponse(t,e){this._nullCheck();const r=128*t;this._uint8Ptr.array[(r+117)/1]=+e}getDisableDeactivation(t){this._nullCheck();const e=128*t;return!!this._uint8Ptr.array[(e+118)/1]}setDisableDeactivation(t,e){this._nullCheck();const r=128*t;this._uint8Ptr.array[(r+118)/1]=+e}}},54179:(t,e,r)=>{r.r(e),r.d(e,{SceneBuilder:()=>b}),r(90203),r(33832),r(2093),r(42163);var n=r(7839),o=r(52046),i=r(71513),s=r(18595),a=r(26041),l=r(79923),h=r(58144),d=r(73490),c=r(8014),p=r(825),m=r(87491),w=r(46738),u=r(47002),M=r(51137),g=r(99848),_=r(55431),y=r(23948),E=r(35901),f=r(3477),C=r(26405);const P=new l.Pq;class T extends C.SA{localTransform;collisionGroup=1;collisionMask=65535;_material=null;constructor(t,e,r,n){super(t,n?.scaleToRef(.5,P)??P.setAll(.5)),this.localTransform=function(t,e,r){return!1===t?.equalsToFloats(0,0,0)||!1===e?.equalsToFloats(0,0,0,1)?(void 0!==e?(void 0===r&&(r=new l.uq),r=l.uq.FromQuaternionToRef(e,r),void 0!==t&&r.setTranslation(t)):void 0!==t?(void 0===r?r=l.uq.Identity():l.uq.IdentityToRef(r),r.setTranslation(t)):void 0===r?r=l.uq.Identity():l.uq.IdentityToRef(r),r):null}(e,r)}setMaterial(t,e){this._material={friction:t,restitution:e}}get material(){return this._material}}class k{world;name="BulletPlugin";onCollisionObservable=new g.cP;onCollisionEndedObservable=new g.cP;onTriggerCollisionObservable=new g.cP;constructor(t){this.world=new y.h(t)}setGravity(t){this.world.setGravity(t)}setTimeStep(t){this.world.timeStep=t}getTimeStep(){return this.world.timeStep}executeStep(t,e){for(let t=0;t<e.length;++t){const r=e[t];r.disablePreStep||this.setPhysicsBodyTransformation(r,r.transformNode)}this.world.afterAnimations(t);for(let t=0;t<e.length;++t){const r=e[t];r.disableSync||this.sync(r)}}setPhysicsBodyTransformation(t,e){if(t.getPrestepType()==d.f9.TELEPORT){const e=t.transformNode;if(t.numInstances>0&&!e._thinInstanceDataStorage.matrixData)return}else t.getPrestepType()==d.f9.ACTION?this.setTargetTransform(t,e.absolutePosition,e.absoluteRotationQuaternion):t.getPrestepType()==d.f9.DISABLED?M.V.Warn("Prestep type is set to DISABLED. Unable to set physics body transformation."):M.V.Warn("Invalid prestep type set to physics body.")}getPluginVersion(){return 2}setVelocityLimits(t,e){throw new Error("Method not implemented.")}getMaxLinearVelocity(){throw new Error("Method not implemented.")}getMaxAngularVelocity(){throw new Error("Method not implemented.")}static _TempMatrix=new l.uq;initBody(t,e,r,n){const o=t._pluginData=new E.t(this.world.wasmInstance);let i;switch(e){case d.AH.DYNAMIC:i=0;break;case d.AH.STATIC:i=1;break;case d.AH.ANIMATED:i=2;break;default:throw new Error("Invalid motion type")}o.motionType=i;const s=l.uq.FromQuaternionToRef(n,k._TempMatrix);s.setTranslation(r),o.setInitialTransform(s)}initBodyInstances(t,e,r){throw new Error("Method not implemented.")}updateBodyInstances(t,e){throw new Error("Method not implemented.")}removeBody(t){throw new Error("Method not implemented.")}sync(t){throw new Error("Method not implemented.")}syncTransform(t,e){throw new Error("Method not implemented.")}setShape(t,e){throw new Error("Method not implemented.")}getShape(t){throw new Error("Method not implemented.")}getShapeType(t){throw new Error("Method not implemented.")}setEventMask(t,e,r){throw new Error("Method not implemented.")}getEventMask(t,e){throw new Error("Method not implemented.")}setMotionType(t,e,r){throw new Error("Method not implemented.")}getMotionType(t,e){throw new Error("Method not implemented.")}computeMassProperties(t,e){throw new Error("Method not implemented.")}setMassProperties(t,e,r){const n=t._pluginData;if(n instanceof E.t)void 0!==e.mass&&(n.mass=e.mass);else{if(!(n instanceof f.x))throw new Error("mass cannot be set after body is initialized");if(void 0===r)for(let t=0;t<n.count;t++)void 0!==e.mass&&n.setMass(e.mass,t);else void 0!==e.mass&&n.setMass(e.mass,r)}}getMassProperties(t,e){throw new Error("Method not implemented.")}setLinearDamping(t,e,r){throw new Error("Method not implemented.")}getLinearDamping(t,e){throw new Error("Method not implemented.")}setAngularDamping(t,e,r){throw new Error("Method not implemented.")}getAngularDamping(t,e){throw new Error("Method not implemented.")}setLinearVelocity(t,e,r){throw new Error("Method not implemented.")}getLinearVelocityToRef(t,e,r){throw new Error("Method not implemented.")}applyImpulse(t,e,r,n){throw new Error("Method not implemented.")}applyAngularImpulse(t,e,r){throw new Error("Method not implemented.")}applyForce(t,e,r,n){throw new Error("Method not implemented.")}setAngularVelocity(t,e,r){throw new Error("Method not implemented.")}getAngularVelocityToRef(t,e,r){throw new Error("Method not implemented.")}getBodyGeometry(t){throw new Error("Method not implemented.")}disposeBody(t){throw new Error("Method not implemented.")}setCollisionCallbackEnabled(t,e,r){throw new Error("Method not implemented.")}setCollisionEndedCallbackEnabled(t,e,r){throw new Error("Method not implemented.")}addConstraint(t,e,r,n,o){throw new Error("Method not implemented.")}getCollisionObservable(t,e){throw new Error("Method not implemented.")}getCollisionEndedObservable(t,e){throw new Error("Method not implemented.")}setGravityFactor(t,e,r){throw new Error("Method not implemented.")}getGravityFactor(t,e){throw new Error("Method not implemented.")}setTargetTransform(t,e,r,n){throw new Error("Method not implemented.")}initShape(t,e,r){switch(e){case d.DK.SPHERE:throw new Error("Sphere shape not supported.");case d.DK.BOX:t._pluginData=new T(this.world,r.center,r.rotation,r.extents);break;case d.DK.CAPSULE:throw new Error("Capsule shape not supported.");case d.DK.CONTAINER:throw new Error("Container shape not supported.");case d.DK.CYLINDER:throw new Error("Cylinder shape not supported.");case d.DK.CONVEX_HULL:case d.DK.MESH:throw new Error("Convex hull and mesh shapes not supported.");case d.DK.HEIGHTFIELD:throw new Error("Heightfield shape not supported.");default:throw new Error("Unsupported Shape Type.")}}setShapeFilterMembershipMask(t,e){t._pluginData.collisionGroup=e}getShapeFilterMembershipMask(t){return t._pluginData.collisionGroup}setShapeFilterCollideMask(t,e){t._pluginData.collisionMask=e}getShapeFilterCollideMask(t){return t._pluginData.collisionMask}setMaterial(t,e){const r=e.friction??.5;e.staticFriction&&M.V.Warn("Static friction is not supported in bullet.");const n=e.restitution??0;e.frictionCombine&&e.frictionCombine!==_.F.MULTIPLY&&M.V.Warn("Friction combine is fixed to MULTIPLY in bullet."),e.restitutionCombine&&e.restitutionCombine!==_.F.MULTIPLY&&M.V.Warn("Restitution combine is fixed to MULTIPLY in bullet."),t._pluginData.setMaterial(r,n)}getMaterial(t){throw new Error("Method not implemented.")}setDensity(t,e){throw new Error("Method not implemented.")}getDensity(t){throw new Error("Method not implemented.")}addChild(t,e,r,n,o){throw new Error("Method not implemented.")}removeChild(t,e){throw new Error("Method not implemented.")}getNumChildren(t){throw new Error("Method not implemented.")}getBoundingBox(t){throw new Error("Method not implemented.")}getBodyBoundingBox(t){throw new Error("Method not implemented.")}disposeShape(t){throw new Error("Method not implemented.")}setTrigger(t,e){throw new Error("Method not implemented.")}initConstraint(t,e,r){throw new Error("Method not implemented.")}setEnabled(t,e){throw new Error("Method not implemented.")}getEnabled(t){throw new Error("Method not implemented.")}setCollisionsEnabled(t,e){throw new Error("Method not implemented.")}getCollisionsEnabled(t){throw new Error("Method not implemented.")}setAxisFriction(t,e,r){throw new Error("Method not implemented.")}getAxisFriction(t,e){throw new Error("Method not implemented.")}setAxisMode(t,e,r){throw new Error("Method not implemented.")}getAxisMode(t,e){throw new Error("Method not implemented.")}setAxisMinLimit(t,e,r){throw new Error("Method not implemented.")}getAxisMinLimit(t,e){throw new Error("Method not implemented.")}setAxisMaxLimit(t,e,r){throw new Error("Method not implemented.")}getAxisMaxLimit(t,e){throw new Error("Method not implemented.")}setAxisMotorType(t,e,r){throw new Error("Method not implemented.")}getAxisMotorType(t,e){throw new Error("Method not implemented.")}setAxisMotorTarget(t,e,r){throw new Error("Method not implemented.")}getAxisMotorTarget(t,e){throw new Error("Method not implemented.")}setAxisMotorMaxForce(t,e,r){throw new Error("Method not implemented.")}getAxisMotorMaxForce(t,e){throw new Error("Method not implemented.")}disposeConstraint(t){throw new Error("Method not implemented.")}getBodiesUsingConstraint(t){throw new Error("Method not implemented.")}raycast(t,e,r,n){throw new Error("Method not implemented.")}dispose(){throw new Error("Method not implemented.")}}class b{async build(t,e){const r=new m.Z(e);r.clearColor=new a.ov(.95,.95,.95,1);const M=new n.L("arcRotateCamera",0,0,500,new l.Pq(0,0,0),r);M.minZ=1,M.maxZ=1e3,M.setPosition(new l.Pq(60,40,-50)),M.attachControl(void 0,!1),M.inertia=.8,M.speed=10;const g=new i.g("hemisphericLight",new l.Pq(0,1,0),r);g.intensity=.5,g.specular=new a.v9(0,0,0),g.groundColor=new a.v9(1,1,1);const _=new o.Z("directionalLight",new l.Pq(.5,-1,1),r);_.intensity=.5;_.shadowMaxZ=60,_.shadowMinZ=-60,_.autoCalcShadowZBounds=!1,_.autoUpdateExtends=!1,_.shadowOrthoScale=0,_.orthoTop=60,_.orthoBottom=-60,_.orthoLeft=-60,_.orthoRight=60;const y=new s.o(2048,_,!0);y.transparencyShadow=!0,y.usePercentageCloserFiltering=!0,y.forceBackFacesOnly=!1,y.bias=.004,y.filteringQuality=s.o.QUALITY_MEDIUM;const E=await(0,w.e)(new u.t,2);r.enablePhysics(new l.Pq(0,-9.8,0),new k(E));{const t=(0,h.x)("ground",{size:120},r);t.rotationQuaternion=l.PT.RotationAxis(new l.Pq(1,0,0),Math.PI/2),y.addShadowCaster(t),t.receiveShadows=!0;const e=new p.cL(new l.Pq(0,0,-100),l.PT.Identity(),new l.Pq(1e3,1e3,200),r);e.material={friction:10,restitution:.5},e.filterCollideMask=65535,e.filterMembershipMask=1;const n=new c.a(t,d.AH.STATIC,!1,r);n.setMassProperties({mass:0}),n.setLinearDamping(.3),n.setAngularDamping(.3),n.computeMassProperties()}return r}}}}]);