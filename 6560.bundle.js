"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[6560],{84179:(e,n,t)=>{t.r(n),t.d(n,{SceneBuilder:()=>R}),t(90203),t(33832),t(2093);var o=t(8943),a=t(7839),r=t(52046),s=t(71513),i=t(18595),c=t(26041),l=t(79923),w=t(96793),p=t(58144),u=t(87491),d=t(46738),h=t(67168),f=t(2090),m=t(27744),g=t(91167),T=t(15733),b=t(26405),y=t(1592),P=t(35901),x=t(89800),q=t(32399);class R{async build(e,n){const t=new u.Z(n);t.clearColor=new c.ov(.95,.95,.95,1);const R=new a.L("arcRotateCamera",0,0,500,new l.Pq(0,0,0),t);R.minZ=1,R.maxZ=3e3,R.setPosition(new l.Pq(60,40,-50).scaleInPlace(10)),R.attachControl(void 0,!1),R.inertia=.8,R.speed=10;const S=new s.g("hemisphericLight",new l.Pq(0,1,0),t);S.intensity=.5,S.specular=new c.v9(0,0,0),S.groundColor=new c.v9(1,1,1);const I=new r.Z("directionalLight",new l.Pq(.5,-1,1),t);I.intensity=.5;I.shadowMaxZ=250,I.shadowMinZ=-250,I.autoCalcShadowZBounds=!1,I.autoUpdateExtends=!1,I.shadowOrthoScale=0,I.orthoTop=250,I.orthoBottom=-250,I.orthoLeft=-250,I.orthoRight=250;const L=new i.o(2048,I,!0);L.transparencyShadow=!0,L.usePercentageCloserFiltering=!0,L.forceBackFacesOnly=!1,L.bias=.004,L.filteringQuality=i.o.QUALITY_MEDIUM;const C=parseInt(prompt("Thread count","2"));console.log("Thread count:",C);const v=1===C?await(0,d.e)(new g.Z):await(0,d.e)(new m.t,C),M=new f.D(v),B=new T.F(M,!0),Q=new l.uq;{const e=(0,p.x)("ground",{size:500},t);e.rotationQuaternion=l.PT.RotationAxis(new l.Pq(1,0,0),Math.PI/2),L.addShadowCaster(e),e.receiveShadows=!0;const n=new b.Ty(M,new l.Pq(0,0,-1),0),o=new P.t(v);o.shape=n,l.uq.FromQuaternionToRef(e.rotationQuaternion,Q),o.setInitialTransform(Q),o.motionType=1;const a=new y.U(M,o);B.addRigidBodyToGlobal(a)}const Z=512,F=[],U=[];if("u"===prompt("Shape type (u, r) uniform box, random","u")){const e=new l.Pq(1,1,1),n=new b.SA(M,e),t={type:"box",size:e};for(let e=0;e<Z;++e)F.push(n),U.push(t)}else{const e=new q.q(0);for(let n=0;n<Z;++n){const n=2*e.next()|0;if(0===n){const n=2*e.next()+.5,t=2*e.next()+.5,o=2*e.next()+.5,a=new l.Pq(n,t,o);F.push(new b.SA(M,a)),U.push({type:"box",size:a})}else{if(1!==n)throw new Error("Invalid type");{const n=2*e.next()+1;F.push(new b.O4(M,n)),U.push({type:"sphere",radius:n})}}}}const A=[];for(let e=0;e<4;++e)for(let n=0;n<8;++n){const t=8*e+n,o=60*(n-4)+30,a=60*(e-2)+30,r=[];for(let e=0;e<Z;++e){const n=new P.t(v);n.shape=F[e];const t=l.uq.TranslationToRef(o,1+2*e,a,Q);n.setInitialTransform(t),n.friction=1,n.linearDamping=.3,n.angularDamping=.3,r.push(n)}for(let e=0;e<Z;++e){const n=r[e],o=new y.U(M,n);B.addRigidBody(o,t),A.push(o)}for(let e=0;e<Z;e+=2){const n=[t*Z+e,t*Z+e+1],o=new h.vC(M,A[n[0]],A[n[1]],l.uq.Translation(0,-1.2,0),l.uq.Translation(0,1.2,0),!0);o.setLinearLowerLimit(new l.Pq(0,0,0)),o.setLinearUpperLimit(new l.Pq(0,0,0)),o.setAngularLowerLimit(new l.Pq(Math.PI/4,0,0)),o.setAngularUpperLimit(new l.Pq(0,0,0));for(let e=0;e<6;++e)o.enableSpring(e,!0),o.setStiffness(e,100),o.setDamping(e,1);B.addConstraint(o,t,!0)}}console.log("Rigid body count:",16384);const k=[],z=(0,w.an)("baseBox",{size:1},t),D=(0,o._6X)("baseSphere",{diameter:1},t);z.setEnabled(!1),D.setEnabled(!1),z.receiveShadows=!0,D.receiveShadows=!0;for(let e=0;e<16384;++e){const n=U[e%U.length],t="box"===n.type?z.createInstance(`boxInstance${e}`):D.createInstance(`sphereInstance${e}`);L.addShadowCaster(t),t.scaling.copyFrom("box"===n.type?n.size.scale(2):new l.Pq(n.radius,n.radius,n.radius).scale(2)),t.rotationQuaternion=l.PT.Identity(),k.push(t)}return new x.X((()=>{const e=performance.now();B.stepSimulation(1/60,10,1/60);for(let e=0;e<A.length;++e){A[e].getTransformMatrixToRef(Q);const n=k[e];Q.getTranslationToRef(n.position),l.PT.FromRotationMatrixToRef(Q,n.rotationQuaternion)}const n=performance.now(),o=n-e;return t.render(),[o,performance.now()-n]})).runBench(),t.onBeforeRenderObservable.add((()=>{B.stepSimulation(1/60,10,1/60);for(let e=0;e<A.length;++e){A[e].getTransformMatrixToRef(Q);const n=k[e];Q.getTranslationToRef(n.position),l.PT.FromRotationMatrixToRef(Q,n.rotationQuaternion)}})),t}}}}]);