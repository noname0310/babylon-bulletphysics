"use strict";(self.webpackChunkbabylon_bulletphysics=self.webpackChunkbabylon_bulletphysics||[]).push([[6942],{6942:(e,t,n)=>{n.r(t),n.d(t,{SceneBuilder:()=>A}),n(203),n(1503),n(8227);var r=n(7456),i=n(5581),s=n(1513),a=n(9711),o=n(6041),c=n(9923),h=n(9899),f=n(8144),l=n(554),u=n(6738),w=n(7168),d=n(3948),m=n(9009),p=n(7002),y=n(6405),_=n(1592),R=n(7648),g=n(5901),L=n(3477);class A{async build(e,t){const n=new l.Z(t);n.clearColor=new o.ov(.95,.95,.95,1);const A=new r.Lq("arcRotateCamera",0,0,500,new c.Pq(0,0,0),n);A.minZ=1,A.maxZ=3e3,A.setPosition(new c.Pq(60,40,-50).scaleInPlace(10)),A.attachControl(void 0,!1),A.inertia=.8,A.speed=10;const S=new s.g("hemisphericLight",new c.Pq(0,1,0),n);S.intensity=.5,S.specular=new o.v9(0,0,0),S.groundColor=new o.v9(1,1,1);const I=new i.Z("directionalLight",new c.Pq(.5,-1,1),n);I.intensity=.5;I.shadowMaxZ=250,I.shadowMinZ=-250,I.autoCalcShadowZBounds=!1,I.autoUpdateExtends=!1,I.shadowOrthoScale=0,I.orthoTop=250,I.orthoBottom=-250,I.orthoLeft=-250,I.orthoRight=250;const b=new a.o(2048,I,!0);b.transparencyShadow=!0,b.usePercentageCloserFiltering=!0,b.forceBackFacesOnly=!1,b.bias=.004,b.filteringQuality=a.o.QUALITY_MEDIUM;const C=await(0,u.e)(new p.t,32),T=new d.h(C,{allowDynamicShadow:!0,preserveBackBuffer:!0});T.register(n),T.evaluationType=m.q.Immediate;const B=new c.uq;{const e=(0,f.x)("ground",{size:500},n);e.rotationQuaternion=c.PT.RotationAxis(new c.Pq(1,0,0),Math.PI/2),b.addShadowCaster(e),e.receiveShadows=!0;const t=new y.Ty(T,new c.Pq(0,0,-1),0),r=new g.t(C);r.shape=t,c.uq.FromQuaternionToRef(e.rotationQuaternion,B),r.setInitialTransform(B),r.motionType=1;const i=new _.U(T,r);T.addRigidBodyToGlobal(i)}const v=512,k=(0,h.an)("box",{size:2},n);b.addShadowCaster(k),k.receiveShadows=!0;const x=new Float32Array(262144);k.thinInstanceSetBuffer("matrix",x,16,!1);const q=new Float32Array(65536),P=["#ff0000","#00ff00","#0000ff","#ffff00","#ff00ff","#00ffff"];for(let e=0;e<32;++e){const t=o.ov.FromHexString(P[e%P.length]);for(let n=0;n<v;++n)q[e*v*4+4*n+0]=t.r,q[e*v*4+4*n+1]=t.g,q[e*v*4+4*n+2]=t.b,q[e*v*4+4*n+3]=t.a}k.thinInstanceSetBuffer("color",q,4,!1);const U=new y.SA(T,new c.Pq(1,1,1)),F=[];for(let e=0;e<4;++e)for(let t=0;t<8;++t){const n=8*e+t,r=20*(t-4)+10,i=20*(e-2)+10,s=new L.x(C,v);for(let e=0;e<v;++e){s.setShape(e,U);const t=c.uq.TranslationToRef(r,1+2*e,i,B);s.setInitialTransform(e,t),s.setFriction(e,1),s.setLinearDamping(e,.3),s.setAngularDamping(e,.3)}const a=new R.Y(T,s);T.addRigidBodyBundle(a,n);for(let e=0;e<32;++e)e!==n&&T.addRigidBodyBundleShadow(a,e);for(let e=0;e<v;e+=2){const t=[e,e+1],r=new w.vC(T,a,t,c.uq.Translation(0,-1.2,0),c.uq.Translation(0,1.2,0),!0);r.setLinearLowerLimit(new c.Pq(0,0,0)),r.setLinearUpperLimit(new c.Pq(0,0,0)),r.setAngularLowerLimit(new c.Pq(Math.PI/4,0,0)),r.setAngularUpperLimit(new c.Pq(0,0,0));for(let e=0;e<6;++e)r.enableSpring(e,!0),r.setStiffness(e,100),r.setDamping(e,1);T.addConstraint(r,n,!1)}F.push(a)}return T.onTickObservable.add((()=>{for(let e=0;e<F.length;++e)F[e].getTransformMatricesToArray(x,e*v*16);k.thinInstanceBufferUpdated("matrix")})),n}}},7168:(e,t,n)=>{n.d(t,{o6:()=>c,vC:()=>h});class r{_wasmInstance;_ptr;_bodyReference;_referenceCount;constructor(e,t,n){this._wasmInstance=e,this._ptr=t,this._bodyReference=n,Array.isArray(n)?(n[0].addReference(),n[1].addReference()):n.addReference(),this._referenceCount=0}dispose(){if(this._referenceCount>0)throw new Error("Cannot dispose constraint while it still has references");0!==this._ptr&&(this._wasmInstance.deref()?.destroyConstraint(this._ptr),this._ptr=0,Array.isArray(this._bodyReference)?(this._bodyReference[0].removeReference(),this._bodyReference[1].removeReference()):this._bodyReference.removeReference(),this._bodyReference=null)}get ptr(){return this._ptr}addReference(){this._referenceCount+=1}removeReference(){this._referenceCount-=1}get hasReferences(){return 0<this._referenceCount}}function i(e){e.dispose()}const s=new WeakMap;class a{runtime;_inner;_worldReference;constructor(e,t,n){if(Array.isArray(n)){if(n[0].runtime!==e||n[1].runtime!==e)throw new Error("Cannot create constraint between bodies from different runtimes")}else if(n.runtime!==e)throw new Error("Cannot create constraint between body and bundle from different runtimes");this.runtime=e,this._inner=new r(new WeakRef(e.wasmInstance),t,n),this._worldReference=null;let a=s.get(e.wasmInstance);void 0===a&&(a=new FinalizationRegistry(i),s.set(e.wasmInstance,a)),a.register(this,this._inner,this)}dispose(){if(0===this._inner.ptr)return;this._inner.dispose();const e=s.get(this.runtime.wasmInstance);e?.unregister(this)}get ptr(){return this._inner.ptr}addReference(){this._inner.addReference()}removeReference(){this._inner.removeReference()}setWorldReference(e){if(null!==this._worldReference&&null!==e)throw new Error("Cannot add constraint to multiple worlds");this._worldReference!==e&&(this._worldReference=e,null!==e?this._inner.addReference():this._inner.removeReference())}}const o=64;class c extends a{constructor(e,t,n,r,i,s){const a=e.wasmInstance,c=a.allocateBuffer(o),h=a.createTypedArray(Float32Array,c,16);r.copyToArray(h.array);const f=a.allocateBuffer(o),l=a.createTypedArray(Float32Array,f,16);i.copyToArray(l.array);const u=Array.isArray(n),w=u?a.createGeneric6DofConstraintFromBundle(t.ptr,n[0],n[1],c,f,s):a.createGeneric6DofConstraint(t.ptr,n.ptr,c,f,s);a.deallocateBuffer(c,o),a.deallocateBuffer(f,o),super(e,w,u?t:[t,n])}setLinearLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setLinearUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearUpperLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularUpperLimit(this._inner.ptr,e.x,e.y,e.z)}}class h extends a{constructor(e,t,n,r,i,s){const a=e.wasmInstance,c=a.allocateBuffer(o),h=a.createTypedArray(Float32Array,c,16);r.copyToArray(h.array);const f=a.allocateBuffer(o),l=a.createTypedArray(Float32Array,f,16);i.copyToArray(l.array);const u=Array.isArray(n),w=u?a.createGeneric6DofSpringConstraintFromBundle(t.ptr,n[0],n[1],c,f,s):a.createGeneric6DofSpringConstraint(t.ptr,n.ptr,c,f,s);a.deallocateBuffer(c,o),a.deallocateBuffer(f,o),super(e,w,u?t:[t,n])}setLinearLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setLinearUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetLinearUpperLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularLowerLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularLowerLimit(this._inner.ptr,e.x,e.y,e.z)}setAngularUpperLimit(e){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetAngularUpperLimit(this._inner.ptr,e.x,e.y,e.z)}enableSpring(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintEnableSpring(this._inner.ptr,e,t)}setStiffness(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetStiffness(this._inner.ptr,e,t)}setDamping(e,t){this._inner.hasReferences&&this.runtime.lock.wait(),this.runtime.wasmInstance.constraintSetDamping(this._inner.ptr,e,t)}}}}]);